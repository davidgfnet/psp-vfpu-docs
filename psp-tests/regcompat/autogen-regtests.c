#include "test-utils.h"
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
static float outv[128] __attribute__((aligned(16)));
void run_reg_sanity_tests() {
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C000 (0)
  asm volatile(".word 0xd0070080");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070080\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C010 (1)
  asm volatile(".word 0xd0070081");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070081\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C020 (2)
  asm volatile(".word 0xd0070082");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070082\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C030 (3)
  asm volatile(".word 0xd0070083");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070083\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C100 (4)
  asm volatile(".word 0xd0070084");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070084\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C110 (5)
  asm volatile(".word 0xd0070085");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070085\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C120 (6)
  asm volatile(".word 0xd0070086");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070086\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C130 (7)
  asm volatile(".word 0xd0070087");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070087\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C200 (8)
  asm volatile(".word 0xd0070088");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070088\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C210 (9)
  asm volatile(".word 0xd0070089");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070089\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C220 (10)
  asm volatile(".word 0xd007008a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007008a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C230 (11)
  asm volatile(".word 0xd007008b");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007008b\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C300 (12)
  asm volatile(".word 0xd007008c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007008c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C310 (13)
  asm volatile(".word 0xd007008d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007008d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C320 (14)
  asm volatile(".word 0xd007008e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007008e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C330 (15)
  asm volatile(".word 0xd007008f");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007008f\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C400 (16)
  asm volatile(".word 0xd0070090");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070090\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C410 (17)
  asm volatile(".word 0xd0070091");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070091\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C420 (18)
  asm volatile(".word 0xd0070092");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070092\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C430 (19)
  asm volatile(".word 0xd0070093");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070093\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C500 (20)
  asm volatile(".word 0xd0070094");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070094\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C510 (21)
  asm volatile(".word 0xd0070095");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070095\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C520 (22)
  asm volatile(".word 0xd0070096");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070096\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C530 (23)
  asm volatile(".word 0xd0070097");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070097\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C600 (24)
  asm volatile(".word 0xd0070098");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070098\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C610 (25)
  asm volatile(".word 0xd0070099");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0070099\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C620 (26)
  asm volatile(".word 0xd007009a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007009a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C630 (27)
  asm volatile(".word 0xd007009b");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007009b\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C700 (28)
  asm volatile(".word 0xd007009c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007009c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C710 (29)
  asm volatile(".word 0xd007009d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007009d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C720 (30)
  asm volatile(".word 0xd007009e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007009e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C730 (31)
  asm volatile(".word 0xd007009f");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007009f\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R000 (32)
  asm volatile(".word 0xd00700a0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700a0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R001 (33)
  asm volatile(".word 0xd00700a1");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700a1\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R002 (34)
  asm volatile(".word 0xd00700a2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700a2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R003 (35)
  asm volatile(".word 0xd00700a3");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700a3\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R100 (36)
  asm volatile(".word 0xd00700a4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700a4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R101 (37)
  asm volatile(".word 0xd00700a5");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700a5\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R102 (38)
  asm volatile(".word 0xd00700a6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700a6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R103 (39)
  asm volatile(".word 0xd00700a7");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700a7\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R200 (40)
  asm volatile(".word 0xd00700a8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700a8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R201 (41)
  asm volatile(".word 0xd00700a9");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700a9\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R202 (42)
  asm volatile(".word 0xd00700aa");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700aa\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R203 (43)
  asm volatile(".word 0xd00700ab");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ab\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R300 (44)
  asm volatile(".word 0xd00700ac");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ac\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R301 (45)
  asm volatile(".word 0xd00700ad");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ad\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R302 (46)
  asm volatile(".word 0xd00700ae");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ae\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R303 (47)
  asm volatile(".word 0xd00700af");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700af\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R400 (48)
  asm volatile(".word 0xd00700b0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700b0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R401 (49)
  asm volatile(".word 0xd00700b1");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700b1\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R402 (50)
  asm volatile(".word 0xd00700b2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700b2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R403 (51)
  asm volatile(".word 0xd00700b3");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700b3\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R500 (52)
  asm volatile(".word 0xd00700b4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700b4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R501 (53)
  asm volatile(".word 0xd00700b5");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700b5\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R502 (54)
  asm volatile(".word 0xd00700b6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700b6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R503 (55)
  asm volatile(".word 0xd00700b7");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700b7\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R600 (56)
  asm volatile(".word 0xd00700b8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700b8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R601 (57)
  asm volatile(".word 0xd00700b9");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700b9\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R602 (58)
  asm volatile(".word 0xd00700ba");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ba\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R603 (59)
  asm volatile(".word 0xd00700bb");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700bb\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R700 (60)
  asm volatile(".word 0xd00700bc");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700bc\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R701 (61)
  asm volatile(".word 0xd00700bd");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700bd\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R702 (62)
  asm volatile(".word 0xd00700be");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700be\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R703 (63)
  asm volatile(".word 0xd00700bf");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700bf\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C002 (64)
  asm volatile(".word 0xd00700c0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700c0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C012 (65)
  asm volatile(".word 0xd00700c1");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700c1\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C022 (66)
  asm volatile(".word 0xd00700c2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700c2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C032 (67)
  asm volatile(".word 0xd00700c3");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700c3\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C102 (68)
  asm volatile(".word 0xd00700c4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700c4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C112 (69)
  asm volatile(".word 0xd00700c5");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700c5\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C122 (70)
  asm volatile(".word 0xd00700c6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700c6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C132 (71)
  asm volatile(".word 0xd00700c7");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700c7\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C202 (72)
  asm volatile(".word 0xd00700c8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700c8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C212 (73)
  asm volatile(".word 0xd00700c9");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700c9\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C222 (74)
  asm volatile(".word 0xd00700ca");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ca\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C232 (75)
  asm volatile(".word 0xd00700cb");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700cb\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C302 (76)
  asm volatile(".word 0xd00700cc");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700cc\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C312 (77)
  asm volatile(".word 0xd00700cd");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700cd\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C322 (78)
  asm volatile(".word 0xd00700ce");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ce\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C332 (79)
  asm volatile(".word 0xd00700cf");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700cf\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C402 (80)
  asm volatile(".word 0xd00700d0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700d0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C412 (81)
  asm volatile(".word 0xd00700d1");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700d1\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C422 (82)
  asm volatile(".word 0xd00700d2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700d2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C432 (83)
  asm volatile(".word 0xd00700d3");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700d3\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C502 (84)
  asm volatile(".word 0xd00700d4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700d4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C512 (85)
  asm volatile(".word 0xd00700d5");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700d5\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C522 (86)
  asm volatile(".word 0xd00700d6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700d6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C532 (87)
  asm volatile(".word 0xd00700d7");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700d7\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C602 (88)
  asm volatile(".word 0xd00700d8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700d8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C612 (89)
  asm volatile(".word 0xd00700d9");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700d9\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C622 (90)
  asm volatile(".word 0xd00700da");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700da\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C632 (91)
  asm volatile(".word 0xd00700db");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700db\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C702 (92)
  asm volatile(".word 0xd00700dc");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700dc\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C712 (93)
  asm volatile(".word 0xd00700dd");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700dd\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C722 (94)
  asm volatile(".word 0xd00700de");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700de\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p C732 (95)
  asm volatile(".word 0xd00700df");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700df\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R020 (96)
  asm volatile(".word 0xd00700e0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700e0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R021 (97)
  asm volatile(".word 0xd00700e1");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700e1\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R022 (98)
  asm volatile(".word 0xd00700e2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700e2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R023 (99)
  asm volatile(".word 0xd00700e3");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700e3\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R120 (100)
  asm volatile(".word 0xd00700e4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700e4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R121 (101)
  asm volatile(".word 0xd00700e5");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700e5\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R122 (102)
  asm volatile(".word 0xd00700e6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700e6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R123 (103)
  asm volatile(".word 0xd00700e7");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700e7\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R220 (104)
  asm volatile(".word 0xd00700e8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700e8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R221 (105)
  asm volatile(".word 0xd00700e9");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700e9\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R222 (106)
  asm volatile(".word 0xd00700ea");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ea\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R223 (107)
  asm volatile(".word 0xd00700eb");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700eb\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R320 (108)
  asm volatile(".word 0xd00700ec");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ec\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R321 (109)
  asm volatile(".word 0xd00700ed");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ed\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R322 (110)
  asm volatile(".word 0xd00700ee");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ee\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R323 (111)
  asm volatile(".word 0xd00700ef");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ef\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R420 (112)
  asm volatile(".word 0xd00700f0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700f0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R421 (113)
  asm volatile(".word 0xd00700f1");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700f1\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R422 (114)
  asm volatile(".word 0xd00700f2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700f2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R423 (115)
  asm volatile(".word 0xd00700f3");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700f3\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R520 (116)
  asm volatile(".word 0xd00700f4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700f4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R521 (117)
  asm volatile(".word 0xd00700f5");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700f5\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R522 (118)
  asm volatile(".word 0xd00700f6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700f6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R523 (119)
  asm volatile(".word 0xd00700f7");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700f7\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R620 (120)
  asm volatile(".word 0xd00700f8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700f8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R621 (121)
  asm volatile(".word 0xd00700f9");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700f9\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R622 (122)
  asm volatile(".word 0xd00700fa");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700fa\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R623 (123)
  asm volatile(".word 0xd00700fb");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700fb\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R720 (124)
  asm volatile(".word 0xd00700fc");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700fc\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R721 (125)
  asm volatile(".word 0xd00700fd");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700fd\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R722 (126)
  asm volatile(".word 0xd00700fe");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700fe\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.p R723 (127)
  asm volatile(".word 0xd00700ff");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00700ff\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C000 (0)
  asm volatile(".word 0xd0078000");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078000\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C010 (1)
  asm volatile(".word 0xd0078001");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078001\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C020 (2)
  asm volatile(".word 0xd0078002");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078002\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C030 (3)
  asm volatile(".word 0xd0078003");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078003\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C100 (4)
  asm volatile(".word 0xd0078004");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078004\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C110 (5)
  asm volatile(".word 0xd0078005");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078005\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C120 (6)
  asm volatile(".word 0xd0078006");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078006\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C130 (7)
  asm volatile(".word 0xd0078007");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078007\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C200 (8)
  asm volatile(".word 0xd0078008");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078008\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C210 (9)
  asm volatile(".word 0xd0078009");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078009\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C220 (10)
  asm volatile(".word 0xd007800a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007800a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C230 (11)
  asm volatile(".word 0xd007800b");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007800b\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C300 (12)
  asm volatile(".word 0xd007800c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007800c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C310 (13)
  asm volatile(".word 0xd007800d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007800d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C320 (14)
  asm volatile(".word 0xd007800e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007800e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C330 (15)
  asm volatile(".word 0xd007800f");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007800f\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C400 (16)
  asm volatile(".word 0xd0078010");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078010\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C410 (17)
  asm volatile(".word 0xd0078011");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078011\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C420 (18)
  asm volatile(".word 0xd0078012");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078012\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C430 (19)
  asm volatile(".word 0xd0078013");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078013\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C500 (20)
  asm volatile(".word 0xd0078014");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078014\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C510 (21)
  asm volatile(".word 0xd0078015");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078015\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C520 (22)
  asm volatile(".word 0xd0078016");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078016\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C530 (23)
  asm volatile(".word 0xd0078017");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078017\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C600 (24)
  asm volatile(".word 0xd0078018");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078018\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C610 (25)
  asm volatile(".word 0xd0078019");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078019\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C620 (26)
  asm volatile(".word 0xd007801a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007801a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C630 (27)
  asm volatile(".word 0xd007801b");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007801b\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C700 (28)
  asm volatile(".word 0xd007801c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007801c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C710 (29)
  asm volatile(".word 0xd007801d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007801d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C720 (30)
  asm volatile(".word 0xd007801e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007801e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C730 (31)
  asm volatile(".word 0xd007801f");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007801f\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R000 (32)
  asm volatile(".word 0xd0078020");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078020\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R001 (33)
  asm volatile(".word 0xd0078021");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078021\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R002 (34)
  asm volatile(".word 0xd0078022");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078022\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R003 (35)
  asm volatile(".word 0xd0078023");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078023\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R100 (36)
  asm volatile(".word 0xd0078024");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078024\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R101 (37)
  asm volatile(".word 0xd0078025");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078025\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R102 (38)
  asm volatile(".word 0xd0078026");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078026\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R103 (39)
  asm volatile(".word 0xd0078027");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078027\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R200 (40)
  asm volatile(".word 0xd0078028");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078028\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R201 (41)
  asm volatile(".word 0xd0078029");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078029\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R202 (42)
  asm volatile(".word 0xd007802a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007802a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R203 (43)
  asm volatile(".word 0xd007802b");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007802b\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R300 (44)
  asm volatile(".word 0xd007802c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007802c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R301 (45)
  asm volatile(".word 0xd007802d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007802d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R302 (46)
  asm volatile(".word 0xd007802e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007802e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R303 (47)
  asm volatile(".word 0xd007802f");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007802f\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R400 (48)
  asm volatile(".word 0xd0078030");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078030\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R401 (49)
  asm volatile(".word 0xd0078031");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078031\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R402 (50)
  asm volatile(".word 0xd0078032");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078032\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R403 (51)
  asm volatile(".word 0xd0078033");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078033\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R500 (52)
  asm volatile(".word 0xd0078034");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078034\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R501 (53)
  asm volatile(".word 0xd0078035");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078035\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R502 (54)
  asm volatile(".word 0xd0078036");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078036\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R503 (55)
  asm volatile(".word 0xd0078037");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078037\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R600 (56)
  asm volatile(".word 0xd0078038");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078038\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R601 (57)
  asm volatile(".word 0xd0078039");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078039\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R602 (58)
  asm volatile(".word 0xd007803a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007803a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R603 (59)
  asm volatile(".word 0xd007803b");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007803b\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R700 (60)
  asm volatile(".word 0xd007803c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007803c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R701 (61)
  asm volatile(".word 0xd007803d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007803d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R702 (62)
  asm volatile(".word 0xd007803e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007803e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R703 (63)
  asm volatile(".word 0xd007803f");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007803f\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C001 (64)
  asm volatile(".word 0xd0078040");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078040\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C011 (65)
  asm volatile(".word 0xd0078041");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078041\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C021 (66)
  asm volatile(".word 0xd0078042");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078042\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C031 (67)
  asm volatile(".word 0xd0078043");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078043\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C101 (68)
  asm volatile(".word 0xd0078044");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078044\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C111 (69)
  asm volatile(".word 0xd0078045");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078045\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C121 (70)
  asm volatile(".word 0xd0078046");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078046\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C131 (71)
  asm volatile(".word 0xd0078047");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078047\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C201 (72)
  asm volatile(".word 0xd0078048");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078048\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C211 (73)
  asm volatile(".word 0xd0078049");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078049\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C221 (74)
  asm volatile(".word 0xd007804a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007804a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C231 (75)
  asm volatile(".word 0xd007804b");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007804b\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C301 (76)
  asm volatile(".word 0xd007804c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007804c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C311 (77)
  asm volatile(".word 0xd007804d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007804d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C321 (78)
  asm volatile(".word 0xd007804e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007804e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C331 (79)
  asm volatile(".word 0xd007804f");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007804f\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C401 (80)
  asm volatile(".word 0xd0078050");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078050\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C411 (81)
  asm volatile(".word 0xd0078051");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078051\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C421 (82)
  asm volatile(".word 0xd0078052");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078052\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C431 (83)
  asm volatile(".word 0xd0078053");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078053\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C501 (84)
  asm volatile(".word 0xd0078054");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078054\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C511 (85)
  asm volatile(".word 0xd0078055");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078055\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C521 (86)
  asm volatile(".word 0xd0078056");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078056\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C531 (87)
  asm volatile(".word 0xd0078057");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078057\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C601 (88)
  asm volatile(".word 0xd0078058");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078058\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C611 (89)
  asm volatile(".word 0xd0078059");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078059\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C621 (90)
  asm volatile(".word 0xd007805a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007805a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C631 (91)
  asm volatile(".word 0xd007805b");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007805b\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C701 (92)
  asm volatile(".word 0xd007805c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007805c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C711 (93)
  asm volatile(".word 0xd007805d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007805d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C721 (94)
  asm volatile(".word 0xd007805e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007805e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t C731 (95)
  asm volatile(".word 0xd007805f");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007805f\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R010 (96)
  asm volatile(".word 0xd0078060");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078060\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R011 (97)
  asm volatile(".word 0xd0078061");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078061\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R012 (98)
  asm volatile(".word 0xd0078062");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078062\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R013 (99)
  asm volatile(".word 0xd0078063");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078063\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R110 (100)
  asm volatile(".word 0xd0078064");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078064\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R111 (101)
  asm volatile(".word 0xd0078065");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078065\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R112 (102)
  asm volatile(".word 0xd0078066");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078066\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R113 (103)
  asm volatile(".word 0xd0078067");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078067\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R210 (104)
  asm volatile(".word 0xd0078068");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078068\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R211 (105)
  asm volatile(".word 0xd0078069");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078069\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R212 (106)
  asm volatile(".word 0xd007806a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007806a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R213 (107)
  asm volatile(".word 0xd007806b");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007806b\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R310 (108)
  asm volatile(".word 0xd007806c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007806c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R311 (109)
  asm volatile(".word 0xd007806d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007806d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R312 (110)
  asm volatile(".word 0xd007806e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007806e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R313 (111)
  asm volatile(".word 0xd007806f");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007806f\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R410 (112)
  asm volatile(".word 0xd0078070");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078070\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R411 (113)
  asm volatile(".word 0xd0078071");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078071\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R412 (114)
  asm volatile(".word 0xd0078072");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078072\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R413 (115)
  asm volatile(".word 0xd0078073");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078073\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R510 (116)
  asm volatile(".word 0xd0078074");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078074\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R511 (117)
  asm volatile(".word 0xd0078075");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078075\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R512 (118)
  asm volatile(".word 0xd0078076");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078076\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R513 (119)
  asm volatile(".word 0xd0078077");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078077\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R610 (120)
  asm volatile(".word 0xd0078078");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078078\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R611 (121)
  asm volatile(".word 0xd0078079");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078079\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R612 (122)
  asm volatile(".word 0xd007807a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007807a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R613 (123)
  asm volatile(".word 0xd007807b");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007807b\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R710 (124)
  asm volatile(".word 0xd007807c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007807c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R711 (125)
  asm volatile(".word 0xd007807d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007807d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R712 (126)
  asm volatile(".word 0xd007807e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007807e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.t R713 (127)
  asm volatile(".word 0xd007807f");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007807f\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C000 (0)
  asm volatile(".word 0xd0078080");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078080\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C010 (1)
  asm volatile(".word 0xd0078081");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078081\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C020 (2)
  asm volatile(".word 0xd0078082");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078082\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C030 (3)
  asm volatile(".word 0xd0078083");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078083\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C100 (4)
  asm volatile(".word 0xd0078084");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078084\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C110 (5)
  asm volatile(".word 0xd0078085");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078085\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C120 (6)
  asm volatile(".word 0xd0078086");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078086\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C130 (7)
  asm volatile(".word 0xd0078087");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078087\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C200 (8)
  asm volatile(".word 0xd0078088");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078088\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C210 (9)
  asm volatile(".word 0xd0078089");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078089\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C220 (10)
  asm volatile(".word 0xd007808a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007808a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C230 (11)
  asm volatile(".word 0xd007808b");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007808b\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C300 (12)
  asm volatile(".word 0xd007808c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007808c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C310 (13)
  asm volatile(".word 0xd007808d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007808d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C320 (14)
  asm volatile(".word 0xd007808e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007808e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C330 (15)
  asm volatile(".word 0xd007808f");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007808f\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C400 (16)
  asm volatile(".word 0xd0078090");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078090\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C410 (17)
  asm volatile(".word 0xd0078091");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078091\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C420 (18)
  asm volatile(".word 0xd0078092");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078092\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C430 (19)
  asm volatile(".word 0xd0078093");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078093\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C500 (20)
  asm volatile(".word 0xd0078094");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078094\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C510 (21)
  asm volatile(".word 0xd0078095");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078095\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C520 (22)
  asm volatile(".word 0xd0078096");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078096\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C530 (23)
  asm volatile(".word 0xd0078097");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078097\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C600 (24)
  asm volatile(".word 0xd0078098");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078098\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C610 (25)
  asm volatile(".word 0xd0078099");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d0078099\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C620 (26)
  asm volatile(".word 0xd007809a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007809a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C630 (27)
  asm volatile(".word 0xd007809b");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007809b\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C700 (28)
  asm volatile(".word 0xd007809c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007809c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C710 (29)
  asm volatile(".word 0xd007809d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007809d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C720 (30)
  asm volatile(".word 0xd007809e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007809e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q C730 (31)
  asm volatile(".word 0xd007809f");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d007809f\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R000 (32)
  asm volatile(".word 0xd00780a0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780a0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R001 (33)
  asm volatile(".word 0xd00780a1");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780a1\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R002 (34)
  asm volatile(".word 0xd00780a2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780a2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R003 (35)
  asm volatile(".word 0xd00780a3");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780a3\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R100 (36)
  asm volatile(".word 0xd00780a4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780a4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R101 (37)
  asm volatile(".word 0xd00780a5");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780a5\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R102 (38)
  asm volatile(".word 0xd00780a6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780a6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R103 (39)
  asm volatile(".word 0xd00780a7");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780a7\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R200 (40)
  asm volatile(".word 0xd00780a8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780a8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R201 (41)
  asm volatile(".word 0xd00780a9");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780a9\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R202 (42)
  asm volatile(".word 0xd00780aa");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780aa\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R203 (43)
  asm volatile(".word 0xd00780ab");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780ab\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R300 (44)
  asm volatile(".word 0xd00780ac");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780ac\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R301 (45)
  asm volatile(".word 0xd00780ad");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780ad\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R302 (46)
  asm volatile(".word 0xd00780ae");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780ae\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R303 (47)
  asm volatile(".word 0xd00780af");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780af\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R400 (48)
  asm volatile(".word 0xd00780b0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780b0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R401 (49)
  asm volatile(".word 0xd00780b1");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780b1\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R402 (50)
  asm volatile(".word 0xd00780b2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780b2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R403 (51)
  asm volatile(".word 0xd00780b3");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780b3\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R500 (52)
  asm volatile(".word 0xd00780b4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780b4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R501 (53)
  asm volatile(".word 0xd00780b5");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780b5\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R502 (54)
  asm volatile(".word 0xd00780b6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780b6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R503 (55)
  asm volatile(".word 0xd00780b7");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780b7\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R600 (56)
  asm volatile(".word 0xd00780b8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780b8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R601 (57)
  asm volatile(".word 0xd00780b9");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780b9\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R602 (58)
  asm volatile(".word 0xd00780ba");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780ba\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R603 (59)
  asm volatile(".word 0xd00780bb");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780bb\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R700 (60)
  asm volatile(".word 0xd00780bc");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780bc\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R701 (61)
  asm volatile(".word 0xd00780bd");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780bd\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R702 (62)
  asm volatile(".word 0xd00780be");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780be\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vone.q R703 (63)
  asm volatile(".word 0xd00780bf");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("d00780bf\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M000 (0)
  asm volatile(".word 0xf3870080");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3870080\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M020 (2)
  asm volatile(".word 0xf3870082");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3870082\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M100 (4)
  asm volatile(".word 0xf3870084");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3870084\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M120 (6)
  asm volatile(".word 0xf3870086");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3870086\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M200 (8)
  asm volatile(".word 0xf3870088");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3870088\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M220 (10)
  asm volatile(".word 0xf387008a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387008a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M300 (12)
  asm volatile(".word 0xf387008c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387008c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M320 (14)
  asm volatile(".word 0xf387008e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387008e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M400 (16)
  asm volatile(".word 0xf3870090");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3870090\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M420 (18)
  asm volatile(".word 0xf3870092");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3870092\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M500 (20)
  asm volatile(".word 0xf3870094");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3870094\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M520 (22)
  asm volatile(".word 0xf3870096");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3870096\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M600 (24)
  asm volatile(".word 0xf3870098");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3870098\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M620 (26)
  asm volatile(".word 0xf387009a");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387009a\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M700 (28)
  asm volatile(".word 0xf387009c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387009c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M720 (30)
  asm volatile(".word 0xf387009e");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387009e\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M002 (64)
  asm volatile(".word 0xf38700c0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700c0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M022 (66)
  asm volatile(".word 0xf38700c2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700c2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M102 (68)
  asm volatile(".word 0xf38700c4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700c4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M122 (70)
  asm volatile(".word 0xf38700c6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700c6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M202 (72)
  asm volatile(".word 0xf38700c8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700c8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M222 (74)
  asm volatile(".word 0xf38700ca");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700ca\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M302 (76)
  asm volatile(".word 0xf38700cc");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700cc\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M322 (78)
  asm volatile(".word 0xf38700ce");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700ce\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M402 (80)
  asm volatile(".word 0xf38700d0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700d0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M422 (82)
  asm volatile(".word 0xf38700d2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700d2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M502 (84)
  asm volatile(".word 0xf38700d4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700d4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M522 (86)
  asm volatile(".word 0xf38700d6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700d6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M602 (88)
  asm volatile(".word 0xf38700d8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700d8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M622 (90)
  asm volatile(".word 0xf38700da");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700da\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M702 (92)
  asm volatile(".word 0xf38700dc");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700dc\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p M722 (94)
  asm volatile(".word 0xf38700de");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700de\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E000 (32)
  asm volatile(".word 0xf38700a0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700a0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E020 (96)
  asm volatile(".word 0xf38700e0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700e0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E002 (34)
  asm volatile(".word 0xf38700a2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700a2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E022 (98)
  asm volatile(".word 0xf38700e2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700e2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E100 (36)
  asm volatile(".word 0xf38700a4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700a4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E120 (100)
  asm volatile(".word 0xf38700e4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700e4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E102 (38)
  asm volatile(".word 0xf38700a6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700a6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E122 (102)
  asm volatile(".word 0xf38700e6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700e6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E200 (40)
  asm volatile(".word 0xf38700a8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700a8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E220 (104)
  asm volatile(".word 0xf38700e8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700e8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E202 (42)
  asm volatile(".word 0xf38700aa");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700aa\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E222 (106)
  asm volatile(".word 0xf38700ea");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700ea\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E300 (44)
  asm volatile(".word 0xf38700ac");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700ac\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E320 (108)
  asm volatile(".word 0xf38700ec");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700ec\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E302 (46)
  asm volatile(".word 0xf38700ae");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700ae\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E322 (110)
  asm volatile(".word 0xf38700ee");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700ee\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E400 (48)
  asm volatile(".word 0xf38700b0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700b0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E420 (112)
  asm volatile(".word 0xf38700f0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700f0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E402 (50)
  asm volatile(".word 0xf38700b2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700b2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E422 (114)
  asm volatile(".word 0xf38700f2");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700f2\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E500 (52)
  asm volatile(".word 0xf38700b4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700b4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E520 (116)
  asm volatile(".word 0xf38700f4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700f4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E502 (54)
  asm volatile(".word 0xf38700b6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700b6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E522 (118)
  asm volatile(".word 0xf38700f6");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700f6\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E600 (56)
  asm volatile(".word 0xf38700b8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700b8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E620 (120)
  asm volatile(".word 0xf38700f8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700f8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E602 (58)
  asm volatile(".word 0xf38700ba");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700ba\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E622 (122)
  asm volatile(".word 0xf38700fa");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700fa\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E700 (60)
  asm volatile(".word 0xf38700bc");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700bc\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E720 (124)
  asm volatile(".word 0xf38700fc");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700fc\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E702 (62)
  asm volatile(".word 0xf38700be");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700be\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.p E722 (126)
  asm volatile(".word 0xf38700fe");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38700fe\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M000 (0)
  asm volatile(".word 0xf3878000");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878000\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M010 (1)
  asm volatile(".word 0xf3878001");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878001\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E000 (32)
  asm volatile(".word 0xf3878020");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878020\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E001 (33)
  asm volatile(".word 0xf3878021");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878021\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M001 (64)
  asm volatile(".word 0xf3878040");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878040\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M011 (65)
  asm volatile(".word 0xf3878041");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878041\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E010 (96)
  asm volatile(".word 0xf3878060");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878060\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E011 (97)
  asm volatile(".word 0xf3878061");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878061\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M100 (4)
  asm volatile(".word 0xf3878004");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878004\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M110 (5)
  asm volatile(".word 0xf3878005");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878005\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E100 (36)
  asm volatile(".word 0xf3878024");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878024\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E101 (37)
  asm volatile(".word 0xf3878025");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878025\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M101 (68)
  asm volatile(".word 0xf3878044");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878044\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M111 (69)
  asm volatile(".word 0xf3878045");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878045\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E110 (100)
  asm volatile(".word 0xf3878064");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878064\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E111 (101)
  asm volatile(".word 0xf3878065");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878065\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M200 (8)
  asm volatile(".word 0xf3878008");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878008\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M210 (9)
  asm volatile(".word 0xf3878009");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878009\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E200 (40)
  asm volatile(".word 0xf3878028");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878028\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E201 (41)
  asm volatile(".word 0xf3878029");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878029\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M201 (72)
  asm volatile(".word 0xf3878048");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878048\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M211 (73)
  asm volatile(".word 0xf3878049");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878049\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E210 (104)
  asm volatile(".word 0xf3878068");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878068\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E211 (105)
  asm volatile(".word 0xf3878069");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878069\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M300 (12)
  asm volatile(".word 0xf387800c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387800c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M310 (13)
  asm volatile(".word 0xf387800d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387800d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E300 (44)
  asm volatile(".word 0xf387802c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387802c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E301 (45)
  asm volatile(".word 0xf387802d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387802d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M301 (76)
  asm volatile(".word 0xf387804c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387804c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M311 (77)
  asm volatile(".word 0xf387804d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387804d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E310 (108)
  asm volatile(".word 0xf387806c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387806c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E311 (109)
  asm volatile(".word 0xf387806d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387806d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M400 (16)
  asm volatile(".word 0xf3878010");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878010\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M410 (17)
  asm volatile(".word 0xf3878011");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878011\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E400 (48)
  asm volatile(".word 0xf3878030");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878030\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E401 (49)
  asm volatile(".word 0xf3878031");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878031\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M401 (80)
  asm volatile(".word 0xf3878050");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878050\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M411 (81)
  asm volatile(".word 0xf3878051");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878051\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E410 (112)
  asm volatile(".word 0xf3878070");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878070\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E411 (113)
  asm volatile(".word 0xf3878071");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878071\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M500 (20)
  asm volatile(".word 0xf3878014");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878014\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M510 (21)
  asm volatile(".word 0xf3878015");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878015\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E500 (52)
  asm volatile(".word 0xf3878034");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878034\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E501 (53)
  asm volatile(".word 0xf3878035");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878035\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M501 (84)
  asm volatile(".word 0xf3878054");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878054\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M511 (85)
  asm volatile(".word 0xf3878055");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878055\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E510 (116)
  asm volatile(".word 0xf3878074");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878074\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E511 (117)
  asm volatile(".word 0xf3878075");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878075\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M600 (24)
  asm volatile(".word 0xf3878018");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878018\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M610 (25)
  asm volatile(".word 0xf3878019");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878019\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E600 (56)
  asm volatile(".word 0xf3878038");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878038\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E601 (57)
  asm volatile(".word 0xf3878039");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878039\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M601 (88)
  asm volatile(".word 0xf3878058");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878058\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M611 (89)
  asm volatile(".word 0xf3878059");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878059\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E610 (120)
  asm volatile(".word 0xf3878078");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878078\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E611 (121)
  asm volatile(".word 0xf3878079");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878079\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M700 (28)
  asm volatile(".word 0xf387801c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387801c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M710 (29)
  asm volatile(".word 0xf387801d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387801d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E700 (60)
  asm volatile(".word 0xf387803c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387803c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E701 (61)
  asm volatile(".word 0xf387803d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387803d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M701 (92)
  asm volatile(".word 0xf387805c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387805c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t M711 (93)
  asm volatile(".word 0xf387805d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387805d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E710 (124)
  asm volatile(".word 0xf387807c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387807c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.t E711 (125)
  asm volatile(".word 0xf387807d");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387807d\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q M000 (0)
  asm volatile(".word 0xf3878080");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878080\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q M100 (4)
  asm volatile(".word 0xf3878084");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878084\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q M200 (8)
  asm volatile(".word 0xf3878088");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878088\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q M300 (12)
  asm volatile(".word 0xf387808c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387808c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q M400 (16)
  asm volatile(".word 0xf3878090");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878090\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q M500 (20)
  asm volatile(".word 0xf3878094");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878094\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q M600 (24)
  asm volatile(".word 0xf3878098");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f3878098\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q M700 (28)
  asm volatile(".word 0xf387809c");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f387809c\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q E000 (32)
  asm volatile(".word 0xf38780a0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38780a0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q E100 (36)
  asm volatile(".word 0xf38780a4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38780a4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q E200 (40)
  asm volatile(".word 0xf38780a8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38780a8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q E300 (44)
  asm volatile(".word 0xf38780ac");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38780ac\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q E400 (48)
  asm volatile(".word 0xf38780b0");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38780b0\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q E500 (52)
  asm volatile(".word 0xf38780b4");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38780b4\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q E600 (56)
  asm volatile(".word 0xf38780b8");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38780b8\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
  asm volatile("vmzero.q M000;vmzero.q M100;vmzero.q M200;vmzero.q "
               "M300;vmzero.q M400;vmzero.q M500;vmzero.q M600;vmzero.q M700");
  // vmone.q E700 (60)
  asm volatile(".word 0xf38780bc");
  save_all_vfpu_regs(&outv[0]);
  for (unsigned i = 0; i < 128; i++) {
    const char exp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1};
    if (((int)outv[i]) != (int)exp[i]) {
      logprintf("f38780bc\n");
      logprintf("err %d %f %d\n", i, outv[i], (int)exp[i]);
      break;
    }
  }
}
static const unsigned char rmap_single1[] = {
    0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,
    15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
    30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
    45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
    60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,
    75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
    90,  91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104,
    105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
    120, 121, 122, 123, 124, 125, 126, 127,
};
static const unsigned char subreg_map_single1[][1] = {
    {0},   {1},   {2},   {3},   {4},   {5},   {6},   {7},   {8},   {9},   {10},
    {11},  {12},  {13},  {14},  {15},  {16},  {17},  {18},  {19},  {20},  {21},
    {22},  {23},  {24},  {25},  {26},  {27},  {28},  {29},  {30},  {31},  {32},
    {33},  {34},  {35},  {36},  {37},  {38},  {39},  {40},  {41},  {42},  {43},
    {44},  {45},  {46},  {47},  {48},  {49},  {50},  {51},  {52},  {53},  {54},
    {55},  {56},  {57},  {58},  {59},  {60},  {61},  {62},  {63},  {64},  {65},
    {66},  {67},  {68},  {69},  {70},  {71},  {72},  {73},  {74},  {75},  {76},
    {77},  {78},  {79},  {80},  {81},  {82},  {83},  {84},  {85},  {86},  {87},
    {88},  {89},  {90},  {91},  {92},  {93},  {94},  {95},  {96},  {97},  {98},
    {99},  {100}, {101}, {102}, {103}, {104}, {105}, {106}, {107}, {108}, {109},
    {110}, {111}, {112}, {113}, {114}, {115}, {116}, {117}, {118}, {119}, {120},
    {121}, {122}, {123}, {124}, {125}, {126}, {127},
};
static const uint64_t reg_mask_single1[][2] = {
    {0x0000000000000001ULL, 0x0000000000000000ULL},
    {0x0000000000000002ULL, 0x0000000000000000ULL},
    {0x0000000000000004ULL, 0x0000000000000000ULL},
    {0x0000000000000008ULL, 0x0000000000000000ULL},
    {0x0000000000000010ULL, 0x0000000000000000ULL},
    {0x0000000000000020ULL, 0x0000000000000000ULL},
    {0x0000000000000040ULL, 0x0000000000000000ULL},
    {0x0000000000000080ULL, 0x0000000000000000ULL},
    {0x0000000000000100ULL, 0x0000000000000000ULL},
    {0x0000000000000200ULL, 0x0000000000000000ULL},
    {0x0000000000000400ULL, 0x0000000000000000ULL},
    {0x0000000000000800ULL, 0x0000000000000000ULL},
    {0x0000000000001000ULL, 0x0000000000000000ULL},
    {0x0000000000002000ULL, 0x0000000000000000ULL},
    {0x0000000000004000ULL, 0x0000000000000000ULL},
    {0x0000000000008000ULL, 0x0000000000000000ULL},
    {0x0000000000010000ULL, 0x0000000000000000ULL},
    {0x0000000000020000ULL, 0x0000000000000000ULL},
    {0x0000000000040000ULL, 0x0000000000000000ULL},
    {0x0000000000080000ULL, 0x0000000000000000ULL},
    {0x0000000000100000ULL, 0x0000000000000000ULL},
    {0x0000000000200000ULL, 0x0000000000000000ULL},
    {0x0000000000400000ULL, 0x0000000000000000ULL},
    {0x0000000000800000ULL, 0x0000000000000000ULL},
    {0x0000000001000000ULL, 0x0000000000000000ULL},
    {0x0000000002000000ULL, 0x0000000000000000ULL},
    {0x0000000004000000ULL, 0x0000000000000000ULL},
    {0x0000000008000000ULL, 0x0000000000000000ULL},
    {0x0000000010000000ULL, 0x0000000000000000ULL},
    {0x0000000020000000ULL, 0x0000000000000000ULL},
    {0x0000000040000000ULL, 0x0000000000000000ULL},
    {0x0000000080000000ULL, 0x0000000000000000ULL},
    {0x0000000100000000ULL, 0x0000000000000000ULL},
    {0x0000000200000000ULL, 0x0000000000000000ULL},
    {0x0000000400000000ULL, 0x0000000000000000ULL},
    {0x0000000800000000ULL, 0x0000000000000000ULL},
    {0x0000001000000000ULL, 0x0000000000000000ULL},
    {0x0000002000000000ULL, 0x0000000000000000ULL},
    {0x0000004000000000ULL, 0x0000000000000000ULL},
    {0x0000008000000000ULL, 0x0000000000000000ULL},
    {0x0000010000000000ULL, 0x0000000000000000ULL},
    {0x0000020000000000ULL, 0x0000000000000000ULL},
    {0x0000040000000000ULL, 0x0000000000000000ULL},
    {0x0000080000000000ULL, 0x0000000000000000ULL},
    {0x0000100000000000ULL, 0x0000000000000000ULL},
    {0x0000200000000000ULL, 0x0000000000000000ULL},
    {0x0000400000000000ULL, 0x0000000000000000ULL},
    {0x0000800000000000ULL, 0x0000000000000000ULL},
    {0x0001000000000000ULL, 0x0000000000000000ULL},
    {0x0002000000000000ULL, 0x0000000000000000ULL},
    {0x0004000000000000ULL, 0x0000000000000000ULL},
    {0x0008000000000000ULL, 0x0000000000000000ULL},
    {0x0010000000000000ULL, 0x0000000000000000ULL},
    {0x0020000000000000ULL, 0x0000000000000000ULL},
    {0x0040000000000000ULL, 0x0000000000000000ULL},
    {0x0080000000000000ULL, 0x0000000000000000ULL},
    {0x0100000000000000ULL, 0x0000000000000000ULL},
    {0x0200000000000000ULL, 0x0000000000000000ULL},
    {0x0400000000000000ULL, 0x0000000000000000ULL},
    {0x0800000000000000ULL, 0x0000000000000000ULL},
    {0x1000000000000000ULL, 0x0000000000000000ULL},
    {0x2000000000000000ULL, 0x0000000000000000ULL},
    {0x4000000000000000ULL, 0x0000000000000000ULL},
    {0x8000000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000000001ULL},
    {0x0000000000000000ULL, 0x0000000000000002ULL},
    {0x0000000000000000ULL, 0x0000000000000004ULL},
    {0x0000000000000000ULL, 0x0000000000000008ULL},
    {0x0000000000000000ULL, 0x0000000000000010ULL},
    {0x0000000000000000ULL, 0x0000000000000020ULL},
    {0x0000000000000000ULL, 0x0000000000000040ULL},
    {0x0000000000000000ULL, 0x0000000000000080ULL},
    {0x0000000000000000ULL, 0x0000000000000100ULL},
    {0x0000000000000000ULL, 0x0000000000000200ULL},
    {0x0000000000000000ULL, 0x0000000000000400ULL},
    {0x0000000000000000ULL, 0x0000000000000800ULL},
    {0x0000000000000000ULL, 0x0000000000001000ULL},
    {0x0000000000000000ULL, 0x0000000000002000ULL},
    {0x0000000000000000ULL, 0x0000000000004000ULL},
    {0x0000000000000000ULL, 0x0000000000008000ULL},
    {0x0000000000000000ULL, 0x0000000000010000ULL},
    {0x0000000000000000ULL, 0x0000000000020000ULL},
    {0x0000000000000000ULL, 0x0000000000040000ULL},
    {0x0000000000000000ULL, 0x0000000000080000ULL},
    {0x0000000000000000ULL, 0x0000000000100000ULL},
    {0x0000000000000000ULL, 0x0000000000200000ULL},
    {0x0000000000000000ULL, 0x0000000000400000ULL},
    {0x0000000000000000ULL, 0x0000000000800000ULL},
    {0x0000000000000000ULL, 0x0000000001000000ULL},
    {0x0000000000000000ULL, 0x0000000002000000ULL},
    {0x0000000000000000ULL, 0x0000000004000000ULL},
    {0x0000000000000000ULL, 0x0000000008000000ULL},
    {0x0000000000000000ULL, 0x0000000010000000ULL},
    {0x0000000000000000ULL, 0x0000000020000000ULL},
    {0x0000000000000000ULL, 0x0000000040000000ULL},
    {0x0000000000000000ULL, 0x0000000080000000ULL},
    {0x0000000000000000ULL, 0x0000000100000000ULL},
    {0x0000000000000000ULL, 0x0000000200000000ULL},
    {0x0000000000000000ULL, 0x0000000400000000ULL},
    {0x0000000000000000ULL, 0x0000000800000000ULL},
    {0x0000000000000000ULL, 0x0000001000000000ULL},
    {0x0000000000000000ULL, 0x0000002000000000ULL},
    {0x0000000000000000ULL, 0x0000004000000000ULL},
    {0x0000000000000000ULL, 0x0000008000000000ULL},
    {0x0000000000000000ULL, 0x0000010000000000ULL},
    {0x0000000000000000ULL, 0x0000020000000000ULL},
    {0x0000000000000000ULL, 0x0000040000000000ULL},
    {0x0000000000000000ULL, 0x0000080000000000ULL},
    {0x0000000000000000ULL, 0x0000100000000000ULL},
    {0x0000000000000000ULL, 0x0000200000000000ULL},
    {0x0000000000000000ULL, 0x0000400000000000ULL},
    {0x0000000000000000ULL, 0x0000800000000000ULL},
    {0x0000000000000000ULL, 0x0001000000000000ULL},
    {0x0000000000000000ULL, 0x0002000000000000ULL},
    {0x0000000000000000ULL, 0x0004000000000000ULL},
    {0x0000000000000000ULL, 0x0008000000000000ULL},
    {0x0000000000000000ULL, 0x0010000000000000ULL},
    {0x0000000000000000ULL, 0x0020000000000000ULL},
    {0x0000000000000000ULL, 0x0040000000000000ULL},
    {0x0000000000000000ULL, 0x0080000000000000ULL},
    {0x0000000000000000ULL, 0x0100000000000000ULL},
    {0x0000000000000000ULL, 0x0200000000000000ULL},
    {0x0000000000000000ULL, 0x0400000000000000ULL},
    {0x0000000000000000ULL, 0x0800000000000000ULL},
    {0x0000000000000000ULL, 0x1000000000000000ULL},
    {0x0000000000000000ULL, 0x2000000000000000ULL},
    {0x0000000000000000ULL, 0x4000000000000000ULL},
    {0x0000000000000000ULL, 0x8000000000000000ULL},
};
static const unsigned char rmap_vector1[] = {
    0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,
    15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
    30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
    45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
    60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,
    75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
    90,  91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104,
    105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
    120, 121, 122, 123, 124, 125, 126, 127,
};
static const unsigned char subreg_map_vector1[][1] = {
    {0},   {1},   {2},   {3},   {4},   {5},   {6},   {7},   {8},   {9},   {10},
    {11},  {12},  {13},  {14},  {15},  {16},  {17},  {18},  {19},  {20},  {21},
    {22},  {23},  {24},  {25},  {26},  {27},  {28},  {29},  {30},  {31},  {32},
    {33},  {34},  {35},  {36},  {37},  {38},  {39},  {40},  {41},  {42},  {43},
    {44},  {45},  {46},  {47},  {48},  {49},  {50},  {51},  {52},  {53},  {54},
    {55},  {56},  {57},  {58},  {59},  {60},  {61},  {62},  {63},  {64},  {65},
    {66},  {67},  {68},  {69},  {70},  {71},  {72},  {73},  {74},  {75},  {76},
    {77},  {78},  {79},  {80},  {81},  {82},  {83},  {84},  {85},  {86},  {87},
    {88},  {89},  {90},  {91},  {92},  {93},  {94},  {95},  {96},  {97},  {98},
    {99},  {100}, {101}, {102}, {103}, {104}, {105}, {106}, {107}, {108}, {109},
    {110}, {111}, {112}, {113}, {114}, {115}, {116}, {117}, {118}, {119}, {120},
    {121}, {122}, {123}, {124}, {125}, {126}, {127},
};
static const uint64_t reg_mask_vector1[][2] = {
    {0x0000000000000001ULL, 0x0000000000000000ULL},
    {0x0000000000000002ULL, 0x0000000000000000ULL},
    {0x0000000000000004ULL, 0x0000000000000000ULL},
    {0x0000000000000008ULL, 0x0000000000000000ULL},
    {0x0000000000000010ULL, 0x0000000000000000ULL},
    {0x0000000000000020ULL, 0x0000000000000000ULL},
    {0x0000000000000040ULL, 0x0000000000000000ULL},
    {0x0000000000000080ULL, 0x0000000000000000ULL},
    {0x0000000000000100ULL, 0x0000000000000000ULL},
    {0x0000000000000200ULL, 0x0000000000000000ULL},
    {0x0000000000000400ULL, 0x0000000000000000ULL},
    {0x0000000000000800ULL, 0x0000000000000000ULL},
    {0x0000000000001000ULL, 0x0000000000000000ULL},
    {0x0000000000002000ULL, 0x0000000000000000ULL},
    {0x0000000000004000ULL, 0x0000000000000000ULL},
    {0x0000000000008000ULL, 0x0000000000000000ULL},
    {0x0000000000010000ULL, 0x0000000000000000ULL},
    {0x0000000000020000ULL, 0x0000000000000000ULL},
    {0x0000000000040000ULL, 0x0000000000000000ULL},
    {0x0000000000080000ULL, 0x0000000000000000ULL},
    {0x0000000000100000ULL, 0x0000000000000000ULL},
    {0x0000000000200000ULL, 0x0000000000000000ULL},
    {0x0000000000400000ULL, 0x0000000000000000ULL},
    {0x0000000000800000ULL, 0x0000000000000000ULL},
    {0x0000000001000000ULL, 0x0000000000000000ULL},
    {0x0000000002000000ULL, 0x0000000000000000ULL},
    {0x0000000004000000ULL, 0x0000000000000000ULL},
    {0x0000000008000000ULL, 0x0000000000000000ULL},
    {0x0000000010000000ULL, 0x0000000000000000ULL},
    {0x0000000020000000ULL, 0x0000000000000000ULL},
    {0x0000000040000000ULL, 0x0000000000000000ULL},
    {0x0000000080000000ULL, 0x0000000000000000ULL},
    {0x0000000100000000ULL, 0x0000000000000000ULL},
    {0x0000000200000000ULL, 0x0000000000000000ULL},
    {0x0000000400000000ULL, 0x0000000000000000ULL},
    {0x0000000800000000ULL, 0x0000000000000000ULL},
    {0x0000001000000000ULL, 0x0000000000000000ULL},
    {0x0000002000000000ULL, 0x0000000000000000ULL},
    {0x0000004000000000ULL, 0x0000000000000000ULL},
    {0x0000008000000000ULL, 0x0000000000000000ULL},
    {0x0000010000000000ULL, 0x0000000000000000ULL},
    {0x0000020000000000ULL, 0x0000000000000000ULL},
    {0x0000040000000000ULL, 0x0000000000000000ULL},
    {0x0000080000000000ULL, 0x0000000000000000ULL},
    {0x0000100000000000ULL, 0x0000000000000000ULL},
    {0x0000200000000000ULL, 0x0000000000000000ULL},
    {0x0000400000000000ULL, 0x0000000000000000ULL},
    {0x0000800000000000ULL, 0x0000000000000000ULL},
    {0x0001000000000000ULL, 0x0000000000000000ULL},
    {0x0002000000000000ULL, 0x0000000000000000ULL},
    {0x0004000000000000ULL, 0x0000000000000000ULL},
    {0x0008000000000000ULL, 0x0000000000000000ULL},
    {0x0010000000000000ULL, 0x0000000000000000ULL},
    {0x0020000000000000ULL, 0x0000000000000000ULL},
    {0x0040000000000000ULL, 0x0000000000000000ULL},
    {0x0080000000000000ULL, 0x0000000000000000ULL},
    {0x0100000000000000ULL, 0x0000000000000000ULL},
    {0x0200000000000000ULL, 0x0000000000000000ULL},
    {0x0400000000000000ULL, 0x0000000000000000ULL},
    {0x0800000000000000ULL, 0x0000000000000000ULL},
    {0x1000000000000000ULL, 0x0000000000000000ULL},
    {0x2000000000000000ULL, 0x0000000000000000ULL},
    {0x4000000000000000ULL, 0x0000000000000000ULL},
    {0x8000000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000000001ULL},
    {0x0000000000000000ULL, 0x0000000000000002ULL},
    {0x0000000000000000ULL, 0x0000000000000004ULL},
    {0x0000000000000000ULL, 0x0000000000000008ULL},
    {0x0000000000000000ULL, 0x0000000000000010ULL},
    {0x0000000000000000ULL, 0x0000000000000020ULL},
    {0x0000000000000000ULL, 0x0000000000000040ULL},
    {0x0000000000000000ULL, 0x0000000000000080ULL},
    {0x0000000000000000ULL, 0x0000000000000100ULL},
    {0x0000000000000000ULL, 0x0000000000000200ULL},
    {0x0000000000000000ULL, 0x0000000000000400ULL},
    {0x0000000000000000ULL, 0x0000000000000800ULL},
    {0x0000000000000000ULL, 0x0000000000001000ULL},
    {0x0000000000000000ULL, 0x0000000000002000ULL},
    {0x0000000000000000ULL, 0x0000000000004000ULL},
    {0x0000000000000000ULL, 0x0000000000008000ULL},
    {0x0000000000000000ULL, 0x0000000000010000ULL},
    {0x0000000000000000ULL, 0x0000000000020000ULL},
    {0x0000000000000000ULL, 0x0000000000040000ULL},
    {0x0000000000000000ULL, 0x0000000000080000ULL},
    {0x0000000000000000ULL, 0x0000000000100000ULL},
    {0x0000000000000000ULL, 0x0000000000200000ULL},
    {0x0000000000000000ULL, 0x0000000000400000ULL},
    {0x0000000000000000ULL, 0x0000000000800000ULL},
    {0x0000000000000000ULL, 0x0000000001000000ULL},
    {0x0000000000000000ULL, 0x0000000002000000ULL},
    {0x0000000000000000ULL, 0x0000000004000000ULL},
    {0x0000000000000000ULL, 0x0000000008000000ULL},
    {0x0000000000000000ULL, 0x0000000010000000ULL},
    {0x0000000000000000ULL, 0x0000000020000000ULL},
    {0x0000000000000000ULL, 0x0000000040000000ULL},
    {0x0000000000000000ULL, 0x0000000080000000ULL},
    {0x0000000000000000ULL, 0x0000000100000000ULL},
    {0x0000000000000000ULL, 0x0000000200000000ULL},
    {0x0000000000000000ULL, 0x0000000400000000ULL},
    {0x0000000000000000ULL, 0x0000000800000000ULL},
    {0x0000000000000000ULL, 0x0000001000000000ULL},
    {0x0000000000000000ULL, 0x0000002000000000ULL},
    {0x0000000000000000ULL, 0x0000004000000000ULL},
    {0x0000000000000000ULL, 0x0000008000000000ULL},
    {0x0000000000000000ULL, 0x0000010000000000ULL},
    {0x0000000000000000ULL, 0x0000020000000000ULL},
    {0x0000000000000000ULL, 0x0000040000000000ULL},
    {0x0000000000000000ULL, 0x0000080000000000ULL},
    {0x0000000000000000ULL, 0x0000100000000000ULL},
    {0x0000000000000000ULL, 0x0000200000000000ULL},
    {0x0000000000000000ULL, 0x0000400000000000ULL},
    {0x0000000000000000ULL, 0x0000800000000000ULL},
    {0x0000000000000000ULL, 0x0001000000000000ULL},
    {0x0000000000000000ULL, 0x0002000000000000ULL},
    {0x0000000000000000ULL, 0x0004000000000000ULL},
    {0x0000000000000000ULL, 0x0008000000000000ULL},
    {0x0000000000000000ULL, 0x0010000000000000ULL},
    {0x0000000000000000ULL, 0x0020000000000000ULL},
    {0x0000000000000000ULL, 0x0040000000000000ULL},
    {0x0000000000000000ULL, 0x0080000000000000ULL},
    {0x0000000000000000ULL, 0x0100000000000000ULL},
    {0x0000000000000000ULL, 0x0200000000000000ULL},
    {0x0000000000000000ULL, 0x0400000000000000ULL},
    {0x0000000000000000ULL, 0x0800000000000000ULL},
    {0x0000000000000000ULL, 0x1000000000000000ULL},
    {0x0000000000000000ULL, 0x2000000000000000ULL},
    {0x0000000000000000ULL, 0x4000000000000000ULL},
    {0x0000000000000000ULL, 0x8000000000000000ULL},
};
static const unsigned char rmap_vector2[] = {
    0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,
    15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
    30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
    45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
    60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,
    75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
    90,  91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104,
    105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
    120, 121, 122, 123, 124, 125, 126, 127,
};
static const unsigned char subreg_map_vector2[][2] = {
    {0, 32},   {1, 33},    {2, 34},   {3, 35},    {4, 36},   {5, 37},
    {6, 38},   {7, 39},    {8, 40},   {9, 41},    {10, 42},  {11, 43},
    {12, 44},  {13, 45},   {14, 46},  {15, 47},   {16, 48},  {17, 49},
    {18, 50},  {19, 51},   {20, 52},  {21, 53},   {22, 54},  {23, 55},
    {24, 56},  {25, 57},   {26, 58},  {27, 59},   {28, 60},  {29, 61},
    {30, 62},  {31, 63},   {0, 1},    {32, 33},   {64, 65},  {96, 97},
    {4, 5},    {36, 37},   {68, 69},  {100, 101}, {8, 9},    {40, 41},
    {72, 73},  {104, 105}, {12, 13},  {44, 45},   {76, 77},  {108, 109},
    {16, 17},  {48, 49},   {80, 81},  {112, 113}, {20, 21},  {52, 53},
    {84, 85},  {116, 117}, {24, 25},  {56, 57},   {88, 89},  {120, 121},
    {28, 29},  {60, 61},   {92, 93},  {124, 125}, {64, 96},  {65, 97},
    {66, 98},  {67, 99},   {68, 100}, {69, 101},  {70, 102}, {71, 103},
    {72, 104}, {73, 105},  {74, 106}, {75, 107},  {76, 108}, {77, 109},
    {78, 110}, {79, 111},  {80, 112}, {81, 113},  {82, 114}, {83, 115},
    {84, 116}, {85, 117},  {86, 118}, {87, 119},  {88, 120}, {89, 121},
    {90, 122}, {91, 123},  {92, 124}, {93, 125},  {94, 126}, {95, 127},
    {2, 3},    {34, 35},   {66, 67},  {98, 99},   {6, 7},    {38, 39},
    {70, 71},  {102, 103}, {10, 11},  {42, 43},   {74, 75},  {106, 107},
    {14, 15},  {46, 47},   {78, 79},  {110, 111}, {18, 19},  {50, 51},
    {82, 83},  {114, 115}, {22, 23},  {54, 55},   {86, 87},  {118, 119},
    {26, 27},  {58, 59},   {90, 91},  {122, 123}, {30, 31},  {62, 63},
    {94, 95},  {126, 127},
};
static const uint64_t reg_mask_vector2[][2] = {
    {0x0000000100000001ULL, 0x0000000000000000ULL},
    {0x0000000200000002ULL, 0x0000000000000000ULL},
    {0x0000000400000004ULL, 0x0000000000000000ULL},
    {0x0000000800000008ULL, 0x0000000000000000ULL},
    {0x0000001000000010ULL, 0x0000000000000000ULL},
    {0x0000002000000020ULL, 0x0000000000000000ULL},
    {0x0000004000000040ULL, 0x0000000000000000ULL},
    {0x0000008000000080ULL, 0x0000000000000000ULL},
    {0x0000010000000100ULL, 0x0000000000000000ULL},
    {0x0000020000000200ULL, 0x0000000000000000ULL},
    {0x0000040000000400ULL, 0x0000000000000000ULL},
    {0x0000080000000800ULL, 0x0000000000000000ULL},
    {0x0000100000001000ULL, 0x0000000000000000ULL},
    {0x0000200000002000ULL, 0x0000000000000000ULL},
    {0x0000400000004000ULL, 0x0000000000000000ULL},
    {0x0000800000008000ULL, 0x0000000000000000ULL},
    {0x0001000000010000ULL, 0x0000000000000000ULL},
    {0x0002000000020000ULL, 0x0000000000000000ULL},
    {0x0004000000040000ULL, 0x0000000000000000ULL},
    {0x0008000000080000ULL, 0x0000000000000000ULL},
    {0x0010000000100000ULL, 0x0000000000000000ULL},
    {0x0020000000200000ULL, 0x0000000000000000ULL},
    {0x0040000000400000ULL, 0x0000000000000000ULL},
    {0x0080000000800000ULL, 0x0000000000000000ULL},
    {0x0100000001000000ULL, 0x0000000000000000ULL},
    {0x0200000002000000ULL, 0x0000000000000000ULL},
    {0x0400000004000000ULL, 0x0000000000000000ULL},
    {0x0800000008000000ULL, 0x0000000000000000ULL},
    {0x1000000010000000ULL, 0x0000000000000000ULL},
    {0x2000000020000000ULL, 0x0000000000000000ULL},
    {0x4000000040000000ULL, 0x0000000000000000ULL},
    {0x8000000080000000ULL, 0x0000000000000000ULL},
    {0x0000000000000003ULL, 0x0000000000000000ULL},
    {0x0000000300000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000000003ULL},
    {0x0000000000000000ULL, 0x0000000300000000ULL},
    {0x0000000000000030ULL, 0x0000000000000000ULL},
    {0x0000003000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000000030ULL},
    {0x0000000000000000ULL, 0x0000003000000000ULL},
    {0x0000000000000300ULL, 0x0000000000000000ULL},
    {0x0000030000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000000300ULL},
    {0x0000000000000000ULL, 0x0000030000000000ULL},
    {0x0000000000003000ULL, 0x0000000000000000ULL},
    {0x0000300000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000003000ULL},
    {0x0000000000000000ULL, 0x0000300000000000ULL},
    {0x0000000000030000ULL, 0x0000000000000000ULL},
    {0x0003000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000030000ULL},
    {0x0000000000000000ULL, 0x0003000000000000ULL},
    {0x0000000000300000ULL, 0x0000000000000000ULL},
    {0x0030000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000300000ULL},
    {0x0000000000000000ULL, 0x0030000000000000ULL},
    {0x0000000003000000ULL, 0x0000000000000000ULL},
    {0x0300000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000003000000ULL},
    {0x0000000000000000ULL, 0x0300000000000000ULL},
    {0x0000000030000000ULL, 0x0000000000000000ULL},
    {0x3000000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000030000000ULL},
    {0x0000000000000000ULL, 0x3000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000100000001ULL},
    {0x0000000000000000ULL, 0x0000000200000002ULL},
    {0x0000000000000000ULL, 0x0000000400000004ULL},
    {0x0000000000000000ULL, 0x0000000800000008ULL},
    {0x0000000000000000ULL, 0x0000001000000010ULL},
    {0x0000000000000000ULL, 0x0000002000000020ULL},
    {0x0000000000000000ULL, 0x0000004000000040ULL},
    {0x0000000000000000ULL, 0x0000008000000080ULL},
    {0x0000000000000000ULL, 0x0000010000000100ULL},
    {0x0000000000000000ULL, 0x0000020000000200ULL},
    {0x0000000000000000ULL, 0x0000040000000400ULL},
    {0x0000000000000000ULL, 0x0000080000000800ULL},
    {0x0000000000000000ULL, 0x0000100000001000ULL},
    {0x0000000000000000ULL, 0x0000200000002000ULL},
    {0x0000000000000000ULL, 0x0000400000004000ULL},
    {0x0000000000000000ULL, 0x0000800000008000ULL},
    {0x0000000000000000ULL, 0x0001000000010000ULL},
    {0x0000000000000000ULL, 0x0002000000020000ULL},
    {0x0000000000000000ULL, 0x0004000000040000ULL},
    {0x0000000000000000ULL, 0x0008000000080000ULL},
    {0x0000000000000000ULL, 0x0010000000100000ULL},
    {0x0000000000000000ULL, 0x0020000000200000ULL},
    {0x0000000000000000ULL, 0x0040000000400000ULL},
    {0x0000000000000000ULL, 0x0080000000800000ULL},
    {0x0000000000000000ULL, 0x0100000001000000ULL},
    {0x0000000000000000ULL, 0x0200000002000000ULL},
    {0x0000000000000000ULL, 0x0400000004000000ULL},
    {0x0000000000000000ULL, 0x0800000008000000ULL},
    {0x0000000000000000ULL, 0x1000000010000000ULL},
    {0x0000000000000000ULL, 0x2000000020000000ULL},
    {0x0000000000000000ULL, 0x4000000040000000ULL},
    {0x0000000000000000ULL, 0x8000000080000000ULL},
    {0x000000000000000cULL, 0x0000000000000000ULL},
    {0x0000000c00000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x000000000000000cULL},
    {0x0000000000000000ULL, 0x0000000c00000000ULL},
    {0x00000000000000c0ULL, 0x0000000000000000ULL},
    {0x000000c000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x00000000000000c0ULL},
    {0x0000000000000000ULL, 0x000000c000000000ULL},
    {0x0000000000000c00ULL, 0x0000000000000000ULL},
    {0x00000c0000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000000c00ULL},
    {0x0000000000000000ULL, 0x00000c0000000000ULL},
    {0x000000000000c000ULL, 0x0000000000000000ULL},
    {0x0000c00000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x000000000000c000ULL},
    {0x0000000000000000ULL, 0x0000c00000000000ULL},
    {0x00000000000c0000ULL, 0x0000000000000000ULL},
    {0x000c000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x00000000000c0000ULL},
    {0x0000000000000000ULL, 0x000c000000000000ULL},
    {0x0000000000c00000ULL, 0x0000000000000000ULL},
    {0x00c0000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000c00000ULL},
    {0x0000000000000000ULL, 0x00c0000000000000ULL},
    {0x000000000c000000ULL, 0x0000000000000000ULL},
    {0x0c00000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x000000000c000000ULL},
    {0x0000000000000000ULL, 0x0c00000000000000ULL},
    {0x00000000c0000000ULL, 0x0000000000000000ULL},
    {0xc000000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x00000000c0000000ULL},
    {0x0000000000000000ULL, 0xc000000000000000ULL},
};
static const unsigned char rmap_vector3[] = {
    0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,
    15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
    30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
    45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
    60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,
    75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
    90,  91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104,
    105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
    120, 121, 122, 123, 124, 125, 126, 127,
};
static const unsigned char subreg_map_vector3[][3] = {
    {0, 32, 64},   {1, 33, 65},   {2, 34, 66},   {3, 35, 67},
    {4, 36, 68},   {5, 37, 69},   {6, 38, 70},   {7, 39, 71},
    {8, 40, 72},   {9, 41, 73},   {10, 42, 74},  {11, 43, 75},
    {12, 44, 76},  {13, 45, 77},  {14, 46, 78},  {15, 47, 79},
    {16, 48, 80},  {17, 49, 81},  {18, 50, 82},  {19, 51, 83},
    {20, 52, 84},  {21, 53, 85},  {22, 54, 86},  {23, 55, 87},
    {24, 56, 88},  {25, 57, 89},  {26, 58, 90},  {27, 59, 91},
    {28, 60, 92},  {29, 61, 93},  {30, 62, 94},  {31, 63, 95},
    {0, 1, 2},     {32, 33, 34},  {64, 65, 66},  {96, 97, 98},
    {4, 5, 6},     {36, 37, 38},  {68, 69, 70},  {100, 101, 102},
    {8, 9, 10},    {40, 41, 42},  {72, 73, 74},  {104, 105, 106},
    {12, 13, 14},  {44, 45, 46},  {76, 77, 78},  {108, 109, 110},
    {16, 17, 18},  {48, 49, 50},  {80, 81, 82},  {112, 113, 114},
    {20, 21, 22},  {52, 53, 54},  {84, 85, 86},  {116, 117, 118},
    {24, 25, 26},  {56, 57, 58},  {88, 89, 90},  {120, 121, 122},
    {28, 29, 30},  {60, 61, 62},  {92, 93, 94},  {124, 125, 126},
    {32, 64, 96},  {33, 65, 97},  {34, 66, 98},  {35, 67, 99},
    {36, 68, 100}, {37, 69, 101}, {38, 70, 102}, {39, 71, 103},
    {40, 72, 104}, {41, 73, 105}, {42, 74, 106}, {43, 75, 107},
    {44, 76, 108}, {45, 77, 109}, {46, 78, 110}, {47, 79, 111},
    {48, 80, 112}, {49, 81, 113}, {50, 82, 114}, {51, 83, 115},
    {52, 84, 116}, {53, 85, 117}, {54, 86, 118}, {55, 87, 119},
    {56, 88, 120}, {57, 89, 121}, {58, 90, 122}, {59, 91, 123},
    {60, 92, 124}, {61, 93, 125}, {62, 94, 126}, {63, 95, 127},
    {1, 2, 3},     {33, 34, 35},  {65, 66, 67},  {97, 98, 99},
    {5, 6, 7},     {37, 38, 39},  {69, 70, 71},  {101, 102, 103},
    {9, 10, 11},   {41, 42, 43},  {73, 74, 75},  {105, 106, 107},
    {13, 14, 15},  {45, 46, 47},  {77, 78, 79},  {109, 110, 111},
    {17, 18, 19},  {49, 50, 51},  {81, 82, 83},  {113, 114, 115},
    {21, 22, 23},  {53, 54, 55},  {85, 86, 87},  {117, 118, 119},
    {25, 26, 27},  {57, 58, 59},  {89, 90, 91},  {121, 122, 123},
    {29, 30, 31},  {61, 62, 63},  {93, 94, 95},  {125, 126, 127},
};
static const uint64_t reg_mask_vector3[][2] = {
    {0x0000000100000001ULL, 0x0000000000000001ULL},
    {0x0000000200000002ULL, 0x0000000000000002ULL},
    {0x0000000400000004ULL, 0x0000000000000004ULL},
    {0x0000000800000008ULL, 0x0000000000000008ULL},
    {0x0000001000000010ULL, 0x0000000000000010ULL},
    {0x0000002000000020ULL, 0x0000000000000020ULL},
    {0x0000004000000040ULL, 0x0000000000000040ULL},
    {0x0000008000000080ULL, 0x0000000000000080ULL},
    {0x0000010000000100ULL, 0x0000000000000100ULL},
    {0x0000020000000200ULL, 0x0000000000000200ULL},
    {0x0000040000000400ULL, 0x0000000000000400ULL},
    {0x0000080000000800ULL, 0x0000000000000800ULL},
    {0x0000100000001000ULL, 0x0000000000001000ULL},
    {0x0000200000002000ULL, 0x0000000000002000ULL},
    {0x0000400000004000ULL, 0x0000000000004000ULL},
    {0x0000800000008000ULL, 0x0000000000008000ULL},
    {0x0001000000010000ULL, 0x0000000000010000ULL},
    {0x0002000000020000ULL, 0x0000000000020000ULL},
    {0x0004000000040000ULL, 0x0000000000040000ULL},
    {0x0008000000080000ULL, 0x0000000000080000ULL},
    {0x0010000000100000ULL, 0x0000000000100000ULL},
    {0x0020000000200000ULL, 0x0000000000200000ULL},
    {0x0040000000400000ULL, 0x0000000000400000ULL},
    {0x0080000000800000ULL, 0x0000000000800000ULL},
    {0x0100000001000000ULL, 0x0000000001000000ULL},
    {0x0200000002000000ULL, 0x0000000002000000ULL},
    {0x0400000004000000ULL, 0x0000000004000000ULL},
    {0x0800000008000000ULL, 0x0000000008000000ULL},
    {0x1000000010000000ULL, 0x0000000010000000ULL},
    {0x2000000020000000ULL, 0x0000000020000000ULL},
    {0x4000000040000000ULL, 0x0000000040000000ULL},
    {0x8000000080000000ULL, 0x0000000080000000ULL},
    {0x0000000000000007ULL, 0x0000000000000000ULL},
    {0x0000000700000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000000007ULL},
    {0x0000000000000000ULL, 0x0000000700000000ULL},
    {0x0000000000000070ULL, 0x0000000000000000ULL},
    {0x0000007000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000000070ULL},
    {0x0000000000000000ULL, 0x0000007000000000ULL},
    {0x0000000000000700ULL, 0x0000000000000000ULL},
    {0x0000070000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000000700ULL},
    {0x0000000000000000ULL, 0x0000070000000000ULL},
    {0x0000000000007000ULL, 0x0000000000000000ULL},
    {0x0000700000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000007000ULL},
    {0x0000000000000000ULL, 0x0000700000000000ULL},
    {0x0000000000070000ULL, 0x0000000000000000ULL},
    {0x0007000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000070000ULL},
    {0x0000000000000000ULL, 0x0007000000000000ULL},
    {0x0000000000700000ULL, 0x0000000000000000ULL},
    {0x0070000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000700000ULL},
    {0x0000000000000000ULL, 0x0070000000000000ULL},
    {0x0000000007000000ULL, 0x0000000000000000ULL},
    {0x0700000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000007000000ULL},
    {0x0000000000000000ULL, 0x0700000000000000ULL},
    {0x0000000070000000ULL, 0x0000000000000000ULL},
    {0x7000000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000070000000ULL},
    {0x0000000000000000ULL, 0x7000000000000000ULL},
    {0x0000000100000000ULL, 0x0000000100000001ULL},
    {0x0000000200000000ULL, 0x0000000200000002ULL},
    {0x0000000400000000ULL, 0x0000000400000004ULL},
    {0x0000000800000000ULL, 0x0000000800000008ULL},
    {0x0000001000000000ULL, 0x0000001000000010ULL},
    {0x0000002000000000ULL, 0x0000002000000020ULL},
    {0x0000004000000000ULL, 0x0000004000000040ULL},
    {0x0000008000000000ULL, 0x0000008000000080ULL},
    {0x0000010000000000ULL, 0x0000010000000100ULL},
    {0x0000020000000000ULL, 0x0000020000000200ULL},
    {0x0000040000000000ULL, 0x0000040000000400ULL},
    {0x0000080000000000ULL, 0x0000080000000800ULL},
    {0x0000100000000000ULL, 0x0000100000001000ULL},
    {0x0000200000000000ULL, 0x0000200000002000ULL},
    {0x0000400000000000ULL, 0x0000400000004000ULL},
    {0x0000800000000000ULL, 0x0000800000008000ULL},
    {0x0001000000000000ULL, 0x0001000000010000ULL},
    {0x0002000000000000ULL, 0x0002000000020000ULL},
    {0x0004000000000000ULL, 0x0004000000040000ULL},
    {0x0008000000000000ULL, 0x0008000000080000ULL},
    {0x0010000000000000ULL, 0x0010000000100000ULL},
    {0x0020000000000000ULL, 0x0020000000200000ULL},
    {0x0040000000000000ULL, 0x0040000000400000ULL},
    {0x0080000000000000ULL, 0x0080000000800000ULL},
    {0x0100000000000000ULL, 0x0100000001000000ULL},
    {0x0200000000000000ULL, 0x0200000002000000ULL},
    {0x0400000000000000ULL, 0x0400000004000000ULL},
    {0x0800000000000000ULL, 0x0800000008000000ULL},
    {0x1000000000000000ULL, 0x1000000010000000ULL},
    {0x2000000000000000ULL, 0x2000000020000000ULL},
    {0x4000000000000000ULL, 0x4000000040000000ULL},
    {0x8000000000000000ULL, 0x8000000080000000ULL},
    {0x000000000000000eULL, 0x0000000000000000ULL},
    {0x0000000e00000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x000000000000000eULL},
    {0x0000000000000000ULL, 0x0000000e00000000ULL},
    {0x00000000000000e0ULL, 0x0000000000000000ULL},
    {0x000000e000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x00000000000000e0ULL},
    {0x0000000000000000ULL, 0x000000e000000000ULL},
    {0x0000000000000e00ULL, 0x0000000000000000ULL},
    {0x00000e0000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000000e00ULL},
    {0x0000000000000000ULL, 0x00000e0000000000ULL},
    {0x000000000000e000ULL, 0x0000000000000000ULL},
    {0x0000e00000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x000000000000e000ULL},
    {0x0000000000000000ULL, 0x0000e00000000000ULL},
    {0x00000000000e0000ULL, 0x0000000000000000ULL},
    {0x000e000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x00000000000e0000ULL},
    {0x0000000000000000ULL, 0x000e000000000000ULL},
    {0x0000000000e00000ULL, 0x0000000000000000ULL},
    {0x00e0000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000e00000ULL},
    {0x0000000000000000ULL, 0x00e0000000000000ULL},
    {0x000000000e000000ULL, 0x0000000000000000ULL},
    {0x0e00000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x000000000e000000ULL},
    {0x0000000000000000ULL, 0x0e00000000000000ULL},
    {0x00000000e0000000ULL, 0x0000000000000000ULL},
    {0xe000000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x00000000e0000000ULL},
    {0x0000000000000000ULL, 0xe000000000000000ULL},
};
static const unsigned char rmap_vector4[] = {
    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
};
static const unsigned char subreg_map_vector4[][4] = {
    {0, 32, 64, 96},      {1, 33, 65, 97},      {2, 34, 66, 98},
    {3, 35, 67, 99},      {4, 36, 68, 100},     {5, 37, 69, 101},
    {6, 38, 70, 102},     {7, 39, 71, 103},     {8, 40, 72, 104},
    {9, 41, 73, 105},     {10, 42, 74, 106},    {11, 43, 75, 107},
    {12, 44, 76, 108},    {13, 45, 77, 109},    {14, 46, 78, 110},
    {15, 47, 79, 111},    {16, 48, 80, 112},    {17, 49, 81, 113},
    {18, 50, 82, 114},    {19, 51, 83, 115},    {20, 52, 84, 116},
    {21, 53, 85, 117},    {22, 54, 86, 118},    {23, 55, 87, 119},
    {24, 56, 88, 120},    {25, 57, 89, 121},    {26, 58, 90, 122},
    {27, 59, 91, 123},    {28, 60, 92, 124},    {29, 61, 93, 125},
    {30, 62, 94, 126},    {31, 63, 95, 127},    {0, 1, 2, 3},
    {32, 33, 34, 35},     {64, 65, 66, 67},     {96, 97, 98, 99},
    {4, 5, 6, 7},         {36, 37, 38, 39},     {68, 69, 70, 71},
    {100, 101, 102, 103}, {8, 9, 10, 11},       {40, 41, 42, 43},
    {72, 73, 74, 75},     {104, 105, 106, 107}, {12, 13, 14, 15},
    {44, 45, 46, 47},     {76, 77, 78, 79},     {108, 109, 110, 111},
    {16, 17, 18, 19},     {48, 49, 50, 51},     {80, 81, 82, 83},
    {112, 113, 114, 115}, {20, 21, 22, 23},     {52, 53, 54, 55},
    {84, 85, 86, 87},     {116, 117, 118, 119}, {24, 25, 26, 27},
    {56, 57, 58, 59},     {88, 89, 90, 91},     {120, 121, 122, 123},
    {28, 29, 30, 31},     {60, 61, 62, 63},     {92, 93, 94, 95},
    {124, 125, 126, 127},
};
static const uint64_t reg_mask_vector4[][2] = {
    {0x0000000100000001ULL, 0x0000000100000001ULL},
    {0x0000000200000002ULL, 0x0000000200000002ULL},
    {0x0000000400000004ULL, 0x0000000400000004ULL},
    {0x0000000800000008ULL, 0x0000000800000008ULL},
    {0x0000001000000010ULL, 0x0000001000000010ULL},
    {0x0000002000000020ULL, 0x0000002000000020ULL},
    {0x0000004000000040ULL, 0x0000004000000040ULL},
    {0x0000008000000080ULL, 0x0000008000000080ULL},
    {0x0000010000000100ULL, 0x0000010000000100ULL},
    {0x0000020000000200ULL, 0x0000020000000200ULL},
    {0x0000040000000400ULL, 0x0000040000000400ULL},
    {0x0000080000000800ULL, 0x0000080000000800ULL},
    {0x0000100000001000ULL, 0x0000100000001000ULL},
    {0x0000200000002000ULL, 0x0000200000002000ULL},
    {0x0000400000004000ULL, 0x0000400000004000ULL},
    {0x0000800000008000ULL, 0x0000800000008000ULL},
    {0x0001000000010000ULL, 0x0001000000010000ULL},
    {0x0002000000020000ULL, 0x0002000000020000ULL},
    {0x0004000000040000ULL, 0x0004000000040000ULL},
    {0x0008000000080000ULL, 0x0008000000080000ULL},
    {0x0010000000100000ULL, 0x0010000000100000ULL},
    {0x0020000000200000ULL, 0x0020000000200000ULL},
    {0x0040000000400000ULL, 0x0040000000400000ULL},
    {0x0080000000800000ULL, 0x0080000000800000ULL},
    {0x0100000001000000ULL, 0x0100000001000000ULL},
    {0x0200000002000000ULL, 0x0200000002000000ULL},
    {0x0400000004000000ULL, 0x0400000004000000ULL},
    {0x0800000008000000ULL, 0x0800000008000000ULL},
    {0x1000000010000000ULL, 0x1000000010000000ULL},
    {0x2000000020000000ULL, 0x2000000020000000ULL},
    {0x4000000040000000ULL, 0x4000000040000000ULL},
    {0x8000000080000000ULL, 0x8000000080000000ULL},
    {0x000000000000000fULL, 0x0000000000000000ULL},
    {0x0000000f00000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x000000000000000fULL},
    {0x0000000000000000ULL, 0x0000000f00000000ULL},
    {0x00000000000000f0ULL, 0x0000000000000000ULL},
    {0x000000f000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x00000000000000f0ULL},
    {0x0000000000000000ULL, 0x000000f000000000ULL},
    {0x0000000000000f00ULL, 0x0000000000000000ULL},
    {0x00000f0000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000000f00ULL},
    {0x0000000000000000ULL, 0x00000f0000000000ULL},
    {0x000000000000f000ULL, 0x0000000000000000ULL},
    {0x0000f00000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x000000000000f000ULL},
    {0x0000000000000000ULL, 0x0000f00000000000ULL},
    {0x00000000000f0000ULL, 0x0000000000000000ULL},
    {0x000f000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x00000000000f0000ULL},
    {0x0000000000000000ULL, 0x000f000000000000ULL},
    {0x0000000000f00000ULL, 0x0000000000000000ULL},
    {0x00f0000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000000f00000ULL},
    {0x0000000000000000ULL, 0x00f0000000000000ULL},
    {0x000000000f000000ULL, 0x0000000000000000ULL},
    {0x0f00000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x000000000f000000ULL},
    {0x0000000000000000ULL, 0x0f00000000000000ULL},
    {0x00000000f0000000ULL, 0x0000000000000000ULL},
    {0xf000000000000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x00000000f0000000ULL},
    {0x0000000000000000ULL, 0xf000000000000000ULL},
};
static const unsigned char rmap_matrix2[] = {
    0,  2,   4,  6,   8,  10,  12, 14,  16, 18,  20, 22,  24, 26,  28, 30,
    64, 66,  68, 70,  72, 74,  76, 78,  80, 82,  84, 86,  88, 90,  92, 94,
    32, 96,  34, 98,  36, 100, 38, 102, 40, 104, 42, 106, 44, 108, 46, 110,
    48, 112, 50, 114, 52, 116, 54, 118, 56, 120, 58, 122, 60, 124, 62, 126,
};
static const unsigned char subreg_map_matrix2[][4] = {
    {0, 1, 32, 33},     {2, 3, 34, 35},     {4, 5, 36, 37},
    {6, 7, 38, 39},     {8, 9, 40, 41},     {10, 11, 42, 43},
    {12, 13, 44, 45},   {14, 15, 46, 47},   {16, 17, 48, 49},
    {18, 19, 50, 51},   {20, 21, 52, 53},   {22, 23, 54, 55},
    {24, 25, 56, 57},   {26, 27, 58, 59},   {28, 29, 60, 61},
    {30, 31, 62, 63},   {64, 65, 96, 97},   {66, 67, 98, 99},
    {68, 69, 100, 101}, {70, 71, 102, 103}, {72, 73, 104, 105},
    {74, 75, 106, 107}, {76, 77, 108, 109}, {78, 79, 110, 111},
    {80, 81, 112, 113}, {82, 83, 114, 115}, {84, 85, 116, 117},
    {86, 87, 118, 119}, {88, 89, 120, 121}, {90, 91, 122, 123},
    {92, 93, 124, 125}, {94, 95, 126, 127}, {0, 32, 1, 33},
    {2, 34, 3, 35},     {64, 96, 65, 97},   {66, 98, 67, 99},
    {4, 36, 5, 37},     {6, 38, 7, 39},     {68, 100, 69, 101},
    {70, 102, 71, 103}, {8, 40, 9, 41},     {10, 42, 11, 43},
    {72, 104, 73, 105}, {74, 106, 75, 107}, {12, 44, 13, 45},
    {14, 46, 15, 47},   {76, 108, 77, 109}, {78, 110, 79, 111},
    {16, 48, 17, 49},   {18, 50, 19, 51},   {80, 112, 81, 113},
    {82, 114, 83, 115}, {20, 52, 21, 53},   {22, 54, 23, 55},
    {84, 116, 85, 117}, {86, 118, 87, 119}, {24, 56, 25, 57},
    {26, 58, 27, 59},   {88, 120, 89, 121}, {90, 122, 91, 123},
    {28, 60, 29, 61},   {30, 62, 31, 63},   {92, 124, 93, 125},
    {94, 126, 95, 127},
};
static const uint64_t reg_mask_matrix2[][2] = {
    {0x0000000300000003ULL, 0x0000000000000000ULL},
    {0x0000000c0000000cULL, 0x0000000000000000ULL},
    {0x0000003000000030ULL, 0x0000000000000000ULL},
    {0x000000c0000000c0ULL, 0x0000000000000000ULL},
    {0x0000030000000300ULL, 0x0000000000000000ULL},
    {0x00000c0000000c00ULL, 0x0000000000000000ULL},
    {0x0000300000003000ULL, 0x0000000000000000ULL},
    {0x0000c0000000c000ULL, 0x0000000000000000ULL},
    {0x0003000000030000ULL, 0x0000000000000000ULL},
    {0x000c0000000c0000ULL, 0x0000000000000000ULL},
    {0x0030000000300000ULL, 0x0000000000000000ULL},
    {0x00c0000000c00000ULL, 0x0000000000000000ULL},
    {0x0300000003000000ULL, 0x0000000000000000ULL},
    {0x0c0000000c000000ULL, 0x0000000000000000ULL},
    {0x3000000030000000ULL, 0x0000000000000000ULL},
    {0xc0000000c0000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000300000003ULL},
    {0x0000000000000000ULL, 0x0000000c0000000cULL},
    {0x0000000000000000ULL, 0x0000003000000030ULL},
    {0x0000000000000000ULL, 0x000000c0000000c0ULL},
    {0x0000000000000000ULL, 0x0000030000000300ULL},
    {0x0000000000000000ULL, 0x00000c0000000c00ULL},
    {0x0000000000000000ULL, 0x0000300000003000ULL},
    {0x0000000000000000ULL, 0x0000c0000000c000ULL},
    {0x0000000000000000ULL, 0x0003000000030000ULL},
    {0x0000000000000000ULL, 0x000c0000000c0000ULL},
    {0x0000000000000000ULL, 0x0030000000300000ULL},
    {0x0000000000000000ULL, 0x00c0000000c00000ULL},
    {0x0000000000000000ULL, 0x0300000003000000ULL},
    {0x0000000000000000ULL, 0x0c0000000c000000ULL},
    {0x0000000000000000ULL, 0x3000000030000000ULL},
    {0x0000000000000000ULL, 0xc0000000c0000000ULL},
    {0x0000000300000003ULL, 0x0000000000000000ULL},
    {0x0000000c0000000cULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000000300000003ULL},
    {0x0000000000000000ULL, 0x0000000c0000000cULL},
    {0x0000003000000030ULL, 0x0000000000000000ULL},
    {0x000000c0000000c0ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000003000000030ULL},
    {0x0000000000000000ULL, 0x000000c0000000c0ULL},
    {0x0000030000000300ULL, 0x0000000000000000ULL},
    {0x00000c0000000c00ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000030000000300ULL},
    {0x0000000000000000ULL, 0x00000c0000000c00ULL},
    {0x0000300000003000ULL, 0x0000000000000000ULL},
    {0x0000c0000000c000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0000300000003000ULL},
    {0x0000000000000000ULL, 0x0000c0000000c000ULL},
    {0x0003000000030000ULL, 0x0000000000000000ULL},
    {0x000c0000000c0000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0003000000030000ULL},
    {0x0000000000000000ULL, 0x000c0000000c0000ULL},
    {0x0030000000300000ULL, 0x0000000000000000ULL},
    {0x00c0000000c00000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0030000000300000ULL},
    {0x0000000000000000ULL, 0x00c0000000c00000ULL},
    {0x0300000003000000ULL, 0x0000000000000000ULL},
    {0x0c0000000c000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x0300000003000000ULL},
    {0x0000000000000000ULL, 0x0c0000000c000000ULL},
    {0x3000000030000000ULL, 0x0000000000000000ULL},
    {0xc0000000c0000000ULL, 0x0000000000000000ULL},
    {0x0000000000000000ULL, 0x3000000030000000ULL},
    {0x0000000000000000ULL, 0xc0000000c0000000ULL},
};
static const unsigned char rmap_matrix3[] = {
    0,  1,  32, 33, 64, 65, 96,  97,  4,  5,  36, 37, 68, 69, 100, 101,
    8,  9,  40, 41, 72, 73, 104, 105, 12, 13, 44, 45, 76, 77, 108, 109,
    16, 17, 48, 49, 80, 81, 112, 113, 20, 21, 52, 53, 84, 85, 116, 117,
    24, 25, 56, 57, 88, 89, 120, 121, 28, 29, 60, 61, 92, 93, 124, 125,
};
static const unsigned char subreg_map_matrix3[][9] = {
    {0, 1, 2, 32, 33, 34, 64, 65, 66},
    {1, 2, 3, 33, 34, 35, 65, 66, 67},
    {0, 32, 64, 1, 33, 65, 2, 34, 66},
    {32, 64, 96, 33, 65, 97, 34, 66, 98},
    {32, 33, 34, 64, 65, 66, 96, 97, 98},
    {33, 34, 35, 65, 66, 67, 97, 98, 99},
    {1, 33, 65, 2, 34, 66, 3, 35, 67},
    {33, 65, 97, 34, 66, 98, 35, 67, 99},
    {4, 5, 6, 36, 37, 38, 68, 69, 70},
    {5, 6, 7, 37, 38, 39, 69, 70, 71},
    {4, 36, 68, 5, 37, 69, 6, 38, 70},
    {36, 68, 100, 37, 69, 101, 38, 70, 102},
    {36, 37, 38, 68, 69, 70, 100, 101, 102},
    {37, 38, 39, 69, 70, 71, 101, 102, 103},
    {5, 37, 69, 6, 38, 70, 7, 39, 71},
    {37, 69, 101, 38, 70, 102, 39, 71, 103},
    {8, 9, 10, 40, 41, 42, 72, 73, 74},
    {9, 10, 11, 41, 42, 43, 73, 74, 75},
    {8, 40, 72, 9, 41, 73, 10, 42, 74},
    {40, 72, 104, 41, 73, 105, 42, 74, 106},
    {40, 41, 42, 72, 73, 74, 104, 105, 106},
    {41, 42, 43, 73, 74, 75, 105, 106, 107},
    {9, 41, 73, 10, 42, 74, 11, 43, 75},
    {41, 73, 105, 42, 74, 106, 43, 75, 107},
    {12, 13, 14, 44, 45, 46, 76, 77, 78},
    {13, 14, 15, 45, 46, 47, 77, 78, 79},
    {12, 44, 76, 13, 45, 77, 14, 46, 78},
    {44, 76, 108, 45, 77, 109, 46, 78, 110},
    {44, 45, 46, 76, 77, 78, 108, 109, 110},
    {45, 46, 47, 77, 78, 79, 109, 110, 111},
    {13, 45, 77, 14, 46, 78, 15, 47, 79},
    {45, 77, 109, 46, 78, 110, 47, 79, 111},
    {16, 17, 18, 48, 49, 50, 80, 81, 82},
    {17, 18, 19, 49, 50, 51, 81, 82, 83},
    {16, 48, 80, 17, 49, 81, 18, 50, 82},
    {48, 80, 112, 49, 81, 113, 50, 82, 114},
    {48, 49, 50, 80, 81, 82, 112, 113, 114},
    {49, 50, 51, 81, 82, 83, 113, 114, 115},
    {17, 49, 81, 18, 50, 82, 19, 51, 83},
    {49, 81, 113, 50, 82, 114, 51, 83, 115},
    {20, 21, 22, 52, 53, 54, 84, 85, 86},
    {21, 22, 23, 53, 54, 55, 85, 86, 87},
    {20, 52, 84, 21, 53, 85, 22, 54, 86},
    {52, 84, 116, 53, 85, 117, 54, 86, 118},
    {52, 53, 54, 84, 85, 86, 116, 117, 118},
    {53, 54, 55, 85, 86, 87, 117, 118, 119},
    {21, 53, 85, 22, 54, 86, 23, 55, 87},
    {53, 85, 117, 54, 86, 118, 55, 87, 119},
    {24, 25, 26, 56, 57, 58, 88, 89, 90},
    {25, 26, 27, 57, 58, 59, 89, 90, 91},
    {24, 56, 88, 25, 57, 89, 26, 58, 90},
    {56, 88, 120, 57, 89, 121, 58, 90, 122},
    {56, 57, 58, 88, 89, 90, 120, 121, 122},
    {57, 58, 59, 89, 90, 91, 121, 122, 123},
    {25, 57, 89, 26, 58, 90, 27, 59, 91},
    {57, 89, 121, 58, 90, 122, 59, 91, 123},
    {28, 29, 30, 60, 61, 62, 92, 93, 94},
    {29, 30, 31, 61, 62, 63, 93, 94, 95},
    {28, 60, 92, 29, 61, 93, 30, 62, 94},
    {60, 92, 124, 61, 93, 125, 62, 94, 126},
    {60, 61, 62, 92, 93, 94, 124, 125, 126},
    {61, 62, 63, 93, 94, 95, 125, 126, 127},
    {29, 61, 93, 30, 62, 94, 31, 63, 95},
    {61, 93, 125, 62, 94, 126, 63, 95, 127},
};
static const uint64_t reg_mask_matrix3[][2] = {
    {0x0000000700000007ULL, 0x0000000000000007ULL},
    {0x0000000e0000000eULL, 0x000000000000000eULL},
    {0x0000000700000007ULL, 0x0000000000000007ULL},
    {0x0000000700000000ULL, 0x0000000700000007ULL},
    {0x0000000700000000ULL, 0x0000000700000007ULL},
    {0x0000000e00000000ULL, 0x0000000e0000000eULL},
    {0x0000000e0000000eULL, 0x000000000000000eULL},
    {0x0000000e00000000ULL, 0x0000000e0000000eULL},
    {0x0000007000000070ULL, 0x0000000000000070ULL},
    {0x000000e0000000e0ULL, 0x00000000000000e0ULL},
    {0x0000007000000070ULL, 0x0000000000000070ULL},
    {0x0000007000000000ULL, 0x0000007000000070ULL},
    {0x0000007000000000ULL, 0x0000007000000070ULL},
    {0x000000e000000000ULL, 0x000000e0000000e0ULL},
    {0x000000e0000000e0ULL, 0x00000000000000e0ULL},
    {0x000000e000000000ULL, 0x000000e0000000e0ULL},
    {0x0000070000000700ULL, 0x0000000000000700ULL},
    {0x00000e0000000e00ULL, 0x0000000000000e00ULL},
    {0x0000070000000700ULL, 0x0000000000000700ULL},
    {0x0000070000000000ULL, 0x0000070000000700ULL},
    {0x0000070000000000ULL, 0x0000070000000700ULL},
    {0x00000e0000000000ULL, 0x00000e0000000e00ULL},
    {0x00000e0000000e00ULL, 0x0000000000000e00ULL},
    {0x00000e0000000000ULL, 0x00000e0000000e00ULL},
    {0x0000700000007000ULL, 0x0000000000007000ULL},
    {0x0000e0000000e000ULL, 0x000000000000e000ULL},
    {0x0000700000007000ULL, 0x0000000000007000ULL},
    {0x0000700000000000ULL, 0x0000700000007000ULL},
    {0x0000700000000000ULL, 0x0000700000007000ULL},
    {0x0000e00000000000ULL, 0x0000e0000000e000ULL},
    {0x0000e0000000e000ULL, 0x000000000000e000ULL},
    {0x0000e00000000000ULL, 0x0000e0000000e000ULL},
    {0x0007000000070000ULL, 0x0000000000070000ULL},
    {0x000e0000000e0000ULL, 0x00000000000e0000ULL},
    {0x0007000000070000ULL, 0x0000000000070000ULL},
    {0x0007000000000000ULL, 0x0007000000070000ULL},
    {0x0007000000000000ULL, 0x0007000000070000ULL},
    {0x000e000000000000ULL, 0x000e0000000e0000ULL},
    {0x000e0000000e0000ULL, 0x00000000000e0000ULL},
    {0x000e000000000000ULL, 0x000e0000000e0000ULL},
    {0x0070000000700000ULL, 0x0000000000700000ULL},
    {0x00e0000000e00000ULL, 0x0000000000e00000ULL},
    {0x0070000000700000ULL, 0x0000000000700000ULL},
    {0x0070000000000000ULL, 0x0070000000700000ULL},
    {0x0070000000000000ULL, 0x0070000000700000ULL},
    {0x00e0000000000000ULL, 0x00e0000000e00000ULL},
    {0x00e0000000e00000ULL, 0x0000000000e00000ULL},
    {0x00e0000000000000ULL, 0x00e0000000e00000ULL},
    {0x0700000007000000ULL, 0x0000000007000000ULL},
    {0x0e0000000e000000ULL, 0x000000000e000000ULL},
    {0x0700000007000000ULL, 0x0000000007000000ULL},
    {0x0700000000000000ULL, 0x0700000007000000ULL},
    {0x0700000000000000ULL, 0x0700000007000000ULL},
    {0x0e00000000000000ULL, 0x0e0000000e000000ULL},
    {0x0e0000000e000000ULL, 0x000000000e000000ULL},
    {0x0e00000000000000ULL, 0x0e0000000e000000ULL},
    {0x7000000070000000ULL, 0x0000000070000000ULL},
    {0xe0000000e0000000ULL, 0x00000000e0000000ULL},
    {0x7000000070000000ULL, 0x0000000070000000ULL},
    {0x7000000000000000ULL, 0x7000000070000000ULL},
    {0x7000000000000000ULL, 0x7000000070000000ULL},
    {0xe000000000000000ULL, 0xe0000000e0000000ULL},
    {0xe0000000e0000000ULL, 0x00000000e0000000ULL},
    {0xe000000000000000ULL, 0xe0000000e0000000ULL},
};
static const unsigned char rmap_matrix4[] = {
    0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
};
static const unsigned char subreg_map_matrix4[][16] = {
    {0, 1, 2, 3, 32, 33, 34, 35, 64, 65, 66, 67, 96, 97, 98, 99},
    {4, 5, 6, 7, 36, 37, 38, 39, 68, 69, 70, 71, 100, 101, 102, 103},
    {8, 9, 10, 11, 40, 41, 42, 43, 72, 73, 74, 75, 104, 105, 106, 107},
    {12, 13, 14, 15, 44, 45, 46, 47, 76, 77, 78, 79, 108, 109, 110, 111},
    {16, 17, 18, 19, 48, 49, 50, 51, 80, 81, 82, 83, 112, 113, 114, 115},
    {20, 21, 22, 23, 52, 53, 54, 55, 84, 85, 86, 87, 116, 117, 118, 119},
    {24, 25, 26, 27, 56, 57, 58, 59, 88, 89, 90, 91, 120, 121, 122, 123},
    {28, 29, 30, 31, 60, 61, 62, 63, 92, 93, 94, 95, 124, 125, 126, 127},
    {0, 32, 64, 96, 1, 33, 65, 97, 2, 34, 66, 98, 3, 35, 67, 99},
    {4, 36, 68, 100, 5, 37, 69, 101, 6, 38, 70, 102, 7, 39, 71, 103},
    {8, 40, 72, 104, 9, 41, 73, 105, 10, 42, 74, 106, 11, 43, 75, 107},
    {12, 44, 76, 108, 13, 45, 77, 109, 14, 46, 78, 110, 15, 47, 79, 111},
    {16, 48, 80, 112, 17, 49, 81, 113, 18, 50, 82, 114, 19, 51, 83, 115},
    {20, 52, 84, 116, 21, 53, 85, 117, 22, 54, 86, 118, 23, 55, 87, 119},
    {24, 56, 88, 120, 25, 57, 89, 121, 26, 58, 90, 122, 27, 59, 91, 123},
    {28, 60, 92, 124, 29, 61, 93, 125, 30, 62, 94, 126, 31, 63, 95, 127},
};
static const uint64_t reg_mask_matrix4[][2] = {
    {0x0000000f0000000fULL, 0x0000000f0000000fULL},
    {0x000000f0000000f0ULL, 0x000000f0000000f0ULL},
    {0x00000f0000000f00ULL, 0x00000f0000000f00ULL},
    {0x0000f0000000f000ULL, 0x0000f0000000f000ULL},
    {0x000f0000000f0000ULL, 0x000f0000000f0000ULL},
    {0x00f0000000f00000ULL, 0x00f0000000f00000ULL},
    {0x0f0000000f000000ULL, 0x0f0000000f000000ULL},
    {0xf0000000f0000000ULL, 0xf0000000f0000000ULL},
    {0x0000000f0000000fULL, 0x0000000f0000000fULL},
    {0x000000f0000000f0ULL, 0x000000f0000000f0ULL},
    {0x00000f0000000f00ULL, 0x00000f0000000f00ULL},
    {0x0000f0000000f000ULL, 0x0000f0000000f000ULL},
    {0x000f0000000f0000ULL, 0x000f0000000f0000ULL},
    {0x00f0000000f00000ULL, 0x00f0000000f00000ULL},
    {0x0f0000000f000000ULL, 0x0f0000000f000000ULL},
    {0xf0000000f0000000ULL, 0xf0000000f0000000ULL},
};
static const uint32_t reg_load_inst[128] = {
    0xc8000000, 0xc8010000, 0xc8020000, 0xc8030000, 0xc8040000, 0xc8050000,
    0xc8060000, 0xc8070000, 0xc8080000, 0xc8090000, 0xc80a0000, 0xc80b0000,
    0xc80c0000, 0xc80d0000, 0xc80e0000, 0xc80f0000, 0xc8100000, 0xc8110000,
    0xc8120000, 0xc8130000, 0xc8140000, 0xc8150000, 0xc8160000, 0xc8170000,
    0xc8180000, 0xc8190000, 0xc81a0000, 0xc81b0000, 0xc81c0000, 0xc81d0000,
    0xc81e0000, 0xc81f0000, 0xc8000001, 0xc8010001, 0xc8020001, 0xc8030001,
    0xc8040001, 0xc8050001, 0xc8060001, 0xc8070001, 0xc8080001, 0xc8090001,
    0xc80a0001, 0xc80b0001, 0xc80c0001, 0xc80d0001, 0xc80e0001, 0xc80f0001,
    0xc8100001, 0xc8110001, 0xc8120001, 0xc8130001, 0xc8140001, 0xc8150001,
    0xc8160001, 0xc8170001, 0xc8180001, 0xc8190001, 0xc81a0001, 0xc81b0001,
    0xc81c0001, 0xc81d0001, 0xc81e0001, 0xc81f0001, 0xc8000002, 0xc8010002,
    0xc8020002, 0xc8030002, 0xc8040002, 0xc8050002, 0xc8060002, 0xc8070002,
    0xc8080002, 0xc8090002, 0xc80a0002, 0xc80b0002, 0xc80c0002, 0xc80d0002,
    0xc80e0002, 0xc80f0002, 0xc8100002, 0xc8110002, 0xc8120002, 0xc8130002,
    0xc8140002, 0xc8150002, 0xc8160002, 0xc8170002, 0xc8180002, 0xc8190002,
    0xc81a0002, 0xc81b0002, 0xc81c0002, 0xc81d0002, 0xc81e0002, 0xc81f0002,
    0xc8000003, 0xc8010003, 0xc8020003, 0xc8030003, 0xc8040003, 0xc8050003,
    0xc8060003, 0xc8070003, 0xc8080003, 0xc8090003, 0xc80a0003, 0xc80b0003,
    0xc80c0003, 0xc80d0003, 0xc80e0003, 0xc80f0003, 0xc8100003, 0xc8110003,
    0xc8120003, 0xc8130003, 0xc8140003, 0xc8150003, 0xc8160003, 0xc8170003,
    0xc8180003, 0xc8190003, 0xc81a0003, 0xc81b0003, 0xc81c0003, 0xc81d0003,
    0xc81e0003, 0xc81f0003,
};
static const uint32_t reg_save_inst[128] = {
    0xe8000000, 0xe8010000, 0xe8020000, 0xe8030000, 0xe8040000, 0xe8050000,
    0xe8060000, 0xe8070000, 0xe8080000, 0xe8090000, 0xe80a0000, 0xe80b0000,
    0xe80c0000, 0xe80d0000, 0xe80e0000, 0xe80f0000, 0xe8100000, 0xe8110000,
    0xe8120000, 0xe8130000, 0xe8140000, 0xe8150000, 0xe8160000, 0xe8170000,
    0xe8180000, 0xe8190000, 0xe81a0000, 0xe81b0000, 0xe81c0000, 0xe81d0000,
    0xe81e0000, 0xe81f0000, 0xe8000001, 0xe8010001, 0xe8020001, 0xe8030001,
    0xe8040001, 0xe8050001, 0xe8060001, 0xe8070001, 0xe8080001, 0xe8090001,
    0xe80a0001, 0xe80b0001, 0xe80c0001, 0xe80d0001, 0xe80e0001, 0xe80f0001,
    0xe8100001, 0xe8110001, 0xe8120001, 0xe8130001, 0xe8140001, 0xe8150001,
    0xe8160001, 0xe8170001, 0xe8180001, 0xe8190001, 0xe81a0001, 0xe81b0001,
    0xe81c0001, 0xe81d0001, 0xe81e0001, 0xe81f0001, 0xe8000002, 0xe8010002,
    0xe8020002, 0xe8030002, 0xe8040002, 0xe8050002, 0xe8060002, 0xe8070002,
    0xe8080002, 0xe8090002, 0xe80a0002, 0xe80b0002, 0xe80c0002, 0xe80d0002,
    0xe80e0002, 0xe80f0002, 0xe8100002, 0xe8110002, 0xe8120002, 0xe8130002,
    0xe8140002, 0xe8150002, 0xe8160002, 0xe8170002, 0xe8180002, 0xe8190002,
    0xe81a0002, 0xe81b0002, 0xe81c0002, 0xe81d0002, 0xe81e0002, 0xe81f0002,
    0xe8000003, 0xe8010003, 0xe8020003, 0xe8030003, 0xe8040003, 0xe8050003,
    0xe8060003, 0xe8070003, 0xe8080003, 0xe8090003, 0xe80a0003, 0xe80b0003,
    0xe80c0003, 0xe80d0003, 0xe80e0003, 0xe80f0003, 0xe8100003, 0xe8110003,
    0xe8120003, 0xe8130003, 0xe8140003, 0xe8150003, 0xe8160003, 0xe8170003,
    0xe8180003, 0xe8190003, 0xe81a0003, 0xe81b0003, 0xe81c0003, 0xe81d0003,
    0xe81e0003, 0xe81f0003,
};
#define regcol(s1, s2) ((((s1)[0] & (s2)[0]) | ((s1)[1] & (s2)[1])) != 0)
#define regcompatcol(r1, s1, r2, s2)                                           \
  (((s1)[0] == (s2)[0]) && ((s1)[1] == (s2)[1]) && (((r1)&0x20) == ((r2)&0x20)))
static uint32_t bg_noise[128] __attribute__((aligned(16)));
static uint32_t instb[64]; // JIT buffer
#define jit_jump0(a0) ((void (*)(void *))instb)(a0);
#define jit_jump1(a0, a1) ((void (*)(void *, void *))instb)(a0, a1);
#define jit_jump2(a0, a1, a2)                                                  \
  ((void (*)(void *, void *, void *))instb)(a0, a1, a2);
#define jit_finish() platform_cache_sync(instb, sizeof(instb));
int run_reg_tests(struct register_compat_info *reginfo) {
  int entrycnt = 0;
  { // Tests for instruction vadd.s (Add elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vadd.s\n");
    reginfo[entrycnt].inst_name = "vadd.s";
    gen_full_rand(0x60000000, &bg_noise[0], 128);
    uint32_t basew = 0x60000000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8c40000;
        instb[2 + 1] = 0xe8880000;
        instb[2] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector1[reg_rt][p]];
            if (regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[2] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector1[reg_rt], reg_mask_vector1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector1[reg_rt], reg_mask_vector1[reg_rt],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vadd.s
  entrycnt++;
  { // Tests for instruction vadd.p (Add elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vadd.p\n");
    reginfo[entrycnt].inst_name = "vadd.p";
    gen_full_rand(0x60000080, &bg_noise[0], 128);
    uint32_t basew = 0x60000080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3] = 0xc8c40005;
        instb[4 + 1] = 0xe8880000;
        instb[5 + 1] = 0xe8880005;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
              for (unsigned p = 0; p < 2; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 2)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_vector2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vadd.p
  entrycnt++;
  { // Tests for instruction vadd.t (Add elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vadd.t\n");
    reginfo[entrycnt].inst_name = "vadd.t";
    gen_full_rand(0x60008000, &bg_noise[0], 128);
    uint32_t basew = 0x60008000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[8 + 1] = 0xe888000a;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vadd.t
  entrycnt++;
  { // Tests for instruction vadd.q (Add elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vadd.q\n");
    reginfo[entrycnt].inst_name = "vadd.q";
    gen_full_rand(0x60008080, &bg_noise[0], 128);
    uint32_t basew = 0x60008080;
    instb[13] = 0x03e00008; // jr ra
    instb[14] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6] = 0xc8c4000a;
        instb[7] = 0xc8c4000f;
        instb[8 + 1] = 0xe8880000;
        instb[9 + 1] = 0xe8880005;
        instb[10 + 1] = 0xe888000a;
        instb[11 + 1] = 0xe888000f;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vadd.q
  entrycnt++;
  { // Tests for instruction vsub.s (Subtract elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsub.s\n");
    reginfo[entrycnt].inst_name = "vsub.s";
    gen_full_rand(0x60800000, &bg_noise[0], 128);
    uint32_t basew = 0x60800000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8c40000;
        instb[2 + 1] = 0xe8880000;
        instb[2] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector1[reg_rt][p]];
            if (regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[2] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector1[reg_rt], reg_mask_vector1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector1[reg_rt], reg_mask_vector1[reg_rt],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsub.s
  entrycnt++;
  { // Tests for instruction vsub.p (Subtract elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsub.p\n");
    reginfo[entrycnt].inst_name = "vsub.p";
    gen_full_rand(0x60800080, &bg_noise[0], 128);
    uint32_t basew = 0x60800080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3] = 0xc8c40005;
        instb[4 + 1] = 0xe8880000;
        instb[5 + 1] = 0xe8880005;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
              for (unsigned p = 0; p < 2; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 2)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_vector2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsub.p
  entrycnt++;
  { // Tests for instruction vsub.t (Subtract elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsub.t\n");
    reginfo[entrycnt].inst_name = "vsub.t";
    gen_full_rand(0x60808000, &bg_noise[0], 128);
    uint32_t basew = 0x60808000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[8 + 1] = 0xe888000a;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsub.t
  entrycnt++;
  { // Tests for instruction vsub.q (Subtract elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsub.q\n");
    reginfo[entrycnt].inst_name = "vsub.q";
    gen_full_rand(0x60808080, &bg_noise[0], 128);
    uint32_t basew = 0x60808080;
    instb[13] = 0x03e00008; // jr ra
    instb[14] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6] = 0xc8c4000a;
        instb[7] = 0xc8c4000f;
        instb[8 + 1] = 0xe8880000;
        instb[9 + 1] = 0xe8880005;
        instb[10 + 1] = 0xe888000a;
        instb[11 + 1] = 0xe888000f;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsub.q
  entrycnt++;
  { // Tests for instruction vmul.s (Multiply elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmul.s\n");
    reginfo[entrycnt].inst_name = "vmul.s";
    gen_full_rand(0x64000000, &bg_noise[0], 128);
    uint32_t basew = 0x64000000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8c40000;
        instb[2 + 1] = 0xe8880000;
        instb[2] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector1[reg_rt][p]];
            if (regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[2] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector1[reg_rt], reg_mask_vector1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector1[reg_rt], reg_mask_vector1[reg_rt],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmul.s
  entrycnt++;
  { // Tests for instruction vmul.p (Multiply elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmul.p\n");
    reginfo[entrycnt].inst_name = "vmul.p";
    gen_full_rand(0x64000080, &bg_noise[0], 128);
    uint32_t basew = 0x64000080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3] = 0xc8c40005;
        instb[4 + 1] = 0xe8880000;
        instb[5 + 1] = 0xe8880005;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
              for (unsigned p = 0; p < 2; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 2)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_vector2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmul.p
  entrycnt++;
  { // Tests for instruction vmul.t (Multiply elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmul.t\n");
    reginfo[entrycnt].inst_name = "vmul.t";
    gen_full_rand(0x64008000, &bg_noise[0], 128);
    uint32_t basew = 0x64008000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[8 + 1] = 0xe888000a;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmul.t
  entrycnt++;
  { // Tests for instruction vmul.q (Multiply elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmul.q\n");
    reginfo[entrycnt].inst_name = "vmul.q";
    gen_full_rand(0x64008080, &bg_noise[0], 128);
    uint32_t basew = 0x64008080;
    instb[13] = 0x03e00008; // jr ra
    instb[14] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6] = 0xc8c4000a;
        instb[7] = 0xc8c4000f;
        instb[8 + 1] = 0xe8880000;
        instb[9 + 1] = 0xe8880005;
        instb[10 + 1] = 0xe888000a;
        instb[11 + 1] = 0xe888000f;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmul.q
  entrycnt++;
  { // Tests for instruction vdiv.s (Divide elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vdiv.s\n");
    reginfo[entrycnt].inst_name = "vdiv.s";
    gen_full_rand(0x63800000, &bg_noise[0], 128);
    uint32_t basew = 0x63800000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8c40000;
        instb[2 + 1] = 0xe8880000;
        instb[2] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector1[reg_rt][p]];
            if (regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[2] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector1[reg_rt], reg_mask_vector1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector1[reg_rt], reg_mask_vector1[reg_rt],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vdiv.s
  entrycnt++;
  { // Tests for instruction vdiv.p (Divide elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vdiv.p\n");
    reginfo[entrycnt].inst_name = "vdiv.p";
    gen_full_rand(0x63800080, &bg_noise[0], 128);
    uint32_t basew = 0x63800080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3] = 0xc8c40005;
        instb[4 + 1] = 0xe8880000;
        instb[5 + 1] = 0xe8880005;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
              for (unsigned p = 0; p < 2; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 2)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_vector2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vdiv.p
  entrycnt++;
  { // Tests for instruction vdiv.t (Divide elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vdiv.t\n");
    reginfo[entrycnt].inst_name = "vdiv.t";
    gen_full_rand(0x63808000, &bg_noise[0], 128);
    uint32_t basew = 0x63808000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[8 + 1] = 0xe888000a;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vdiv.t
  entrycnt++;
  { // Tests for instruction vdiv.q (Divide elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vdiv.q\n");
    reginfo[entrycnt].inst_name = "vdiv.q";
    gen_full_rand(0x63808080, &bg_noise[0], 128);
    uint32_t basew = 0x63808080;
    instb[13] = 0x03e00008; // jr ra
    instb[14] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6] = 0xc8c4000a;
        instb[7] = 0xc8c4000f;
        instb[8 + 1] = 0xe8880000;
        instb[9 + 1] = 0xe8880005;
        instb[10 + 1] = 0xe888000a;
        instb[11 + 1] = 0xe888000f;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vdiv.q
  entrycnt++;
  { // Tests for instruction vmin.s (Select smallest elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmin.s\n");
    reginfo[entrycnt].inst_name = "vmin.s";
    gen_full_rand(0x6d000000, &bg_noise[0], 128);
    uint32_t basew = 0x6d000000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8c40000;
        instb[2 + 1] = 0xe8880000;
        instb[2] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector1[reg_rt][p]];
            if (regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[2] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector1[reg_rt], reg_mask_vector1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector1[reg_rt], reg_mask_vector1[reg_rt],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmin.s
  entrycnt++;
  { // Tests for instruction vmin.p (Select smallest elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmin.p\n");
    reginfo[entrycnt].inst_name = "vmin.p";
    gen_full_rand(0x6d000080, &bg_noise[0], 128);
    uint32_t basew = 0x6d000080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3] = 0xc8c40005;
        instb[4 + 1] = 0xe8880000;
        instb[5 + 1] = 0xe8880005;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
              for (unsigned p = 0; p < 2; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 2)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_vector2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmin.p
  entrycnt++;
  { // Tests for instruction vmin.t (Select smallest elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmin.t\n");
    reginfo[entrycnt].inst_name = "vmin.t";
    gen_full_rand(0x6d008000, &bg_noise[0], 128);
    uint32_t basew = 0x6d008000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[8 + 1] = 0xe888000a;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmin.t
  entrycnt++;
  { // Tests for instruction vmin.q (Select smallest elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmin.q\n");
    reginfo[entrycnt].inst_name = "vmin.q";
    gen_full_rand(0x6d008080, &bg_noise[0], 128);
    uint32_t basew = 0x6d008080;
    instb[13] = 0x03e00008; // jr ra
    instb[14] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6] = 0xc8c4000a;
        instb[7] = 0xc8c4000f;
        instb[8 + 1] = 0xe8880000;
        instb[9 + 1] = 0xe8880005;
        instb[10 + 1] = 0xe888000a;
        instb[11 + 1] = 0xe888000f;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmin.q
  entrycnt++;
  { // Tests for instruction vmax.s (Select biggest elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmax.s\n");
    reginfo[entrycnt].inst_name = "vmax.s";
    gen_full_rand(0x6d800000, &bg_noise[0], 128);
    uint32_t basew = 0x6d800000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8c40000;
        instb[2 + 1] = 0xe8880000;
        instb[2] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector1[reg_rt][p]];
            if (regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[2] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector1[reg_rt], reg_mask_vector1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector1[reg_rt], reg_mask_vector1[reg_rt],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmax.s
  entrycnt++;
  { // Tests for instruction vmax.p (Select biggest elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmax.p\n");
    reginfo[entrycnt].inst_name = "vmax.p";
    gen_full_rand(0x6d800080, &bg_noise[0], 128);
    uint32_t basew = 0x6d800080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3] = 0xc8c40005;
        instb[4 + 1] = 0xe8880000;
        instb[5 + 1] = 0xe8880005;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
              for (unsigned p = 0; p < 2; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 2)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_vector2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmax.p
  entrycnt++;
  { // Tests for instruction vmax.t (Select biggest elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmax.t\n");
    reginfo[entrycnt].inst_name = "vmax.t";
    gen_full_rand(0x6d808000, &bg_noise[0], 128);
    uint32_t basew = 0x6d808000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[8 + 1] = 0xe888000a;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmax.t
  entrycnt++;
  { // Tests for instruction vmax.q (Select biggest elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmax.q\n");
    reginfo[entrycnt].inst_name = "vmax.q";
    gen_full_rand(0x6d808080, &bg_noise[0], 128);
    uint32_t basew = 0x6d808080;
    instb[13] = 0x03e00008; // jr ra
    instb[14] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6] = 0xc8c4000a;
        instb[7] = 0xc8c4000f;
        instb[8 + 1] = 0xe8880000;
        instb[9 + 1] = 0xe8880005;
        instb[10 + 1] = 0xe888000a;
        instb[11 + 1] = 0xe888000f;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmax.q
  entrycnt++;
  { // Tests for instruction vscmp.s (Compare and set elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vscmp.s\n");
    reginfo[entrycnt].inst_name = "vscmp.s";
    gen_full_rand(0x6e800000, &bg_noise[0], 128);
    uint32_t basew = 0x6e800000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8c40000;
        instb[2 + 1] = 0xe8880000;
        instb[2] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector1[reg_rt][p]];
            if (regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[2] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector1[reg_rt], reg_mask_vector1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector1[reg_rt], reg_mask_vector1[reg_rt],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vscmp.s
  entrycnt++;
  { // Tests for instruction vscmp.p (Compare and set elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vscmp.p\n");
    reginfo[entrycnt].inst_name = "vscmp.p";
    gen_full_rand(0x6e800080, &bg_noise[0], 128);
    uint32_t basew = 0x6e800080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3] = 0xc8c40005;
        instb[4 + 1] = 0xe8880000;
        instb[5 + 1] = 0xe8880005;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
              for (unsigned p = 0; p < 2; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 2)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_vector2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vscmp.p
  entrycnt++;
  { // Tests for instruction vscmp.t (Compare and set elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vscmp.t\n");
    reginfo[entrycnt].inst_name = "vscmp.t";
    gen_full_rand(0x6e808000, &bg_noise[0], 128);
    uint32_t basew = 0x6e808000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[8 + 1] = 0xe888000a;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vscmp.t
  entrycnt++;
  { // Tests for instruction vscmp.q (Compare and set elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vscmp.q\n");
    reginfo[entrycnt].inst_name = "vscmp.q";
    gen_full_rand(0x6e808080, &bg_noise[0], 128);
    uint32_t basew = 0x6e808080;
    instb[13] = 0x03e00008; // jr ra
    instb[14] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6] = 0xc8c4000a;
        instb[7] = 0xc8c4000f;
        instb[8 + 1] = 0xe8880000;
        instb[9 + 1] = 0xe8880005;
        instb[10 + 1] = 0xe888000a;
        instb[11 + 1] = 0xe888000f;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vscmp.q
  entrycnt++;
  { // Tests for instruction vsge.s (Compare greater or equal and set elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsge.s\n");
    reginfo[entrycnt].inst_name = "vsge.s";
    gen_full_rand(0x6f000000, &bg_noise[0], 128);
    uint32_t basew = 0x6f000000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8c40000;
        instb[2 + 1] = 0xe8880000;
        instb[2] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector1[reg_rt][p]];
            if (regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[2] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector1[reg_rt], reg_mask_vector1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector1[reg_rt], reg_mask_vector1[reg_rt],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsge.s
  entrycnt++;
  { // Tests for instruction vsge.p (Compare greater or equal and set elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsge.p\n");
    reginfo[entrycnt].inst_name = "vsge.p";
    gen_full_rand(0x6f000080, &bg_noise[0], 128);
    uint32_t basew = 0x6f000080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3] = 0xc8c40005;
        instb[4 + 1] = 0xe8880000;
        instb[5 + 1] = 0xe8880005;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
              for (unsigned p = 0; p < 2; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 2)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_vector2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsge.p
  entrycnt++;
  { // Tests for instruction vsge.t (Compare greater or equal and set elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsge.t\n");
    reginfo[entrycnt].inst_name = "vsge.t";
    gen_full_rand(0x6f008000, &bg_noise[0], 128);
    uint32_t basew = 0x6f008000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[8 + 1] = 0xe888000a;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsge.t
  entrycnt++;
  { // Tests for instruction vsge.q (Compare greater or equal and set elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsge.q\n");
    reginfo[entrycnt].inst_name = "vsge.q";
    gen_full_rand(0x6f008080, &bg_noise[0], 128);
    uint32_t basew = 0x6f008080;
    instb[13] = 0x03e00008; // jr ra
    instb[14] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6] = 0xc8c4000a;
        instb[7] = 0xc8c4000f;
        instb[8 + 1] = 0xe8880000;
        instb[9 + 1] = 0xe8880005;
        instb[10 + 1] = 0xe888000a;
        instb[11 + 1] = 0xe888000f;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsge.q
  entrycnt++;
  { // Tests for instruction vslt.s (Compare less-than and set elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vslt.s\n");
    reginfo[entrycnt].inst_name = "vslt.s";
    gen_full_rand(0x6f800000, &bg_noise[0], 128);
    uint32_t basew = 0x6f800000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8c40000;
        instb[2 + 1] = 0xe8880000;
        instb[2] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector1[reg_rt][p]];
            if (regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[2] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector1[reg_rt], reg_mask_vector1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector1[reg_rt], reg_mask_vector1[reg_rt],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vslt.s
  entrycnt++;
  { // Tests for instruction vslt.p (Compare less-than and set elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vslt.p\n");
    reginfo[entrycnt].inst_name = "vslt.p";
    gen_full_rand(0x6f800080, &bg_noise[0], 128);
    uint32_t basew = 0x6f800080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3] = 0xc8c40005;
        instb[4 + 1] = 0xe8880000;
        instb[5 + 1] = 0xe8880005;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
              for (unsigned p = 0; p < 2; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 2)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_vector2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vslt.p
  entrycnt++;
  { // Tests for instruction vslt.t (Compare less-than and set elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vslt.t\n");
    reginfo[entrycnt].inst_name = "vslt.t";
    gen_full_rand(0x6f808000, &bg_noise[0], 128);
    uint32_t basew = 0x6f808000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[8 + 1] = 0xe888000a;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vslt.t
  entrycnt++;
  { // Tests for instruction vslt.q (Compare less-than and set elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vslt.q\n");
    reginfo[entrycnt].inst_name = "vslt.q";
    gen_full_rand(0x6f808080, &bg_noise[0], 128);
    uint32_t basew = 0x6f808080;
    instb[13] = 0x03e00008; // jr ra
    instb[14] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6] = 0xc8c4000a;
        instb[7] = 0xc8c4000f;
        instb[8 + 1] = 0xe8880000;
        instb[9 + 1] = 0xe8880005;
        instb[10 + 1] = 0xe888000a;
        instb[11 + 1] = 0xe888000f;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vslt.q
  entrycnt++;
  { // Tests for instruction vcrs.t (Partial vector cross product)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vcrs.t\n");
    reginfo[entrycnt].inst_name = "vcrs.t";
    gen_full_rand(0x66808000, &bg_noise[0], 128);
    uint32_t basew = 0x66808000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[8 + 1] = 0xe888000a;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vcrs.t
  entrycnt++;
  { // Tests for instruction vcrsp.t (Vector cross product)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vcrsp.t\n");
    reginfo[entrycnt].inst_name = "vcrsp.t";
    gen_full_rand(0xf2808000, &bg_noise[0], 128);
    uint32_t basew = 0xf2808000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[8 + 1] = 0xe888000a;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vcrsp.t
  entrycnt++;
  { // Tests for instruction vqmul.q (Quaternion multiplication)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vqmul.q\n");
    reginfo[entrycnt].inst_name = "vqmul.q";
    gen_full_rand(0xf2808080, &bg_noise[0], 128);
    uint32_t basew = 0xf2808080;
    instb[13] = 0x03e00008; // jr ra
    instb[14] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6] = 0xc8c4000a;
        instb[7] = 0xc8c4000f;
        instb[8 + 1] = 0xe8880000;
        instb[9 + 1] = 0xe8880005;
        instb[10 + 1] = 0xe888000a;
        instb[11 + 1] = 0xe888000f;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vqmul.q
  entrycnt++;
  { // Tests for instruction vsbn.s (Change exponent scale)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsbn.s\n");
    reginfo[entrycnt].inst_name = "vsbn.s";
    gen_full_rand(0x61000000, &bg_noise[0], 128);
    uint32_t basew = 0x61000000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      unsigned int rs_ref[1];
      gen_inputs_u32(i >> 0, &rs_ref[0], 1);
      unsigned int rt_ref[1];
      gen_inputs_u32(i >> 2, &rt_ref[0], 1);
      {
        unsigned int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8c40000;
        instb[2 + 1] = 0xe8880000;
        instb[2] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector1[reg_rt][p]];
            if (regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[2] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector1[reg_rt], reg_mask_vector1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector1[reg_rt], reg_mask_vector1[reg_rt],
                    rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsbn.s
  entrycnt++;
  { // Tests for instruction vscl.p (Vector scalar scale)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vscl.p\n");
    reginfo[entrycnt].inst_name = "vscl.p";
    gen_full_rand(0x65000080, &bg_noise[0], 128);
    uint32_t basew = 0x65000080;
    instb[6] = 0x03e00008; // jr ra
    instb[7] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3 + 1] = 0xe8880000;
        instb[4 + 1] = 0xe8880005;
        instb[3] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_single1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_single1[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_single1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
              for (unsigned p = 0; p < 2; p++)
                instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[3] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 2)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_single1[reg_rt], reg_mask_vector2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_single1[reg_rt], reg_mask_single1[reg_rt],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vscl.p
  entrycnt++;
  { // Tests for instruction vscl.t (Vector scalar scale)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vscl.t\n");
    reginfo[entrycnt].inst_name = "vscl.t";
    gen_full_rand(0x65008000, &bg_noise[0], 128);
    uint32_t basew = 0x65008000;
    instb[8] = 0x03e00008; // jr ra
    instb[9] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4 + 1] = 0xe8880000;
        instb[5 + 1] = 0xe8880005;
        instb[6 + 1] = 0xe888000a;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_single1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_single1[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_single1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_single1[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_single1[reg_rt], reg_mask_single1[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vscl.t
  entrycnt++;
  { // Tests for instruction vscl.q (Vector scalar scale)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vscl.q\n");
    reginfo[entrycnt].inst_name = "vscl.q";
    gen_full_rand(0x65008080, &bg_noise[0], 128);
    uint32_t basew = 0x65008080;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5 + 1] = 0xe8880000;
        instb[6 + 1] = 0xe8880005;
        instb[7 + 1] = 0xe888000a;
        instb[8 + 1] = 0xe888000f;
        instb[5] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_single1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_single1[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_single1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[5 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[5] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_single1[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_single1[reg_rt], reg_mask_single1[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vscl.q
  entrycnt++;
  { // Tests for instruction vdot.p (Vector dot product)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vdot.p\n");
    reginfo[entrycnt].inst_name = "vdot.p";
    gen_full_rand(0x64800080, &bg_noise[0], 128);
    uint32_t basew = 0x64800080;
    instb[6] = 0x03e00008; // jr ra
    instb[7] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3] = 0xc8c40005;
        instb[4 + 1] = 0xe8880000;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_single1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_single1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_single1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_single1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vdot.p
  entrycnt++;
  { // Tests for instruction vdot.t (Vector dot product)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vdot.t\n");
    reginfo[entrycnt].inst_name = "vdot.t";
    gen_full_rand(0x64808000, &bg_noise[0], 128);
    uint32_t basew = 0x64808000;
    instb[8] = 0x03e00008; // jr ra
    instb[9] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_single1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_single1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_single1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_single1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vdot.t
  entrycnt++;
  { // Tests for instruction vdot.q (Vector dot product)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vdot.q\n");
    reginfo[entrycnt].inst_name = "vdot.q";
    gen_full_rand(0x64808080, &bg_noise[0], 128);
    uint32_t basew = 0x64808080;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6] = 0xc8c4000a;
        instb[7] = 0xc8c4000f;
        instb[8 + 1] = 0xe8880000;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_single1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_single1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_single1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_single1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vdot.q
  entrycnt++;
  { // Tests for instruction vdet.p (2x2 matrix determinant)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vdet.p\n");
    reginfo[entrycnt].inst_name = "vdet.p";
    gen_full_rand(0x67000080, &bg_noise[0], 128);
    uint32_t basew = 0x67000080;
    instb[6] = 0x03e00008; // jr ra
    instb[7] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3] = 0xc8c40005;
        instb[4 + 1] = 0xe8880000;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_single1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_single1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_single1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_single1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vdet.p
  entrycnt++;
  { // Tests for instruction vhdp.p (Homogeneous dot product)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vhdp.p\n");
    reginfo[entrycnt].inst_name = "vhdp.p";
    gen_full_rand(0x66000080, &bg_noise[0], 128);
    uint32_t basew = 0x66000080;
    instb[6] = 0x03e00008; // jr ra
    instb[7] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8c40000;
        instb[3] = 0xc8c40005;
        instb[4 + 1] = 0xe8880000;
        instb[4] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_single1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[4] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector2[reg_rs], reg_mask_single1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_single1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_single1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vhdp.p
  entrycnt++;
  { // Tests for instruction vhdp.t (Homogeneous dot product)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vhdp.t\n");
    reginfo[entrycnt].inst_name = "vhdp.t";
    gen_full_rand(0x66008000, &bg_noise[0], 128);
    uint32_t basew = 0x66008000;
    instb[8] = 0x03e00008; // jr ra
    instb[9] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8c40000;
        instb[4] = 0xc8c40005;
        instb[5] = 0xc8c4000a;
        instb[6 + 1] = 0xe8880000;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_single1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector3[reg_rs], reg_mask_single1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_single1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_single1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vhdp.t
  entrycnt++;
  { // Tests for instruction vhdp.q (Homogeneous dot product)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vhdp.q\n");
    reginfo[entrycnt].inst_name = "vhdp.q";
    gen_full_rand(0x66008080, &bg_noise[0], 128);
    uint32_t basew = 0x66008080;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6] = 0xc8c4000a;
        instb[7] = 0xc8c4000f;
        instb[8 + 1] = 0xe8880000;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
              for (unsigned p = 0; p < 1; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_single1[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 1)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_vector4[reg_rs], reg_mask_single1[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_single1[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_single1[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vhdp.q
  entrycnt++;
  { // Tests for instruction vmov.s (Vector copy)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmov.s\n");
    reginfo[entrycnt].inst_name = "vmov.s";
    gen_full_rand(0xd0000000, &bg_noise[0], 128);
    uint32_t basew = 0xd0000000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmov.s
  entrycnt++;
  { // Tests for instruction vmov.p (Vector copy)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmov.p\n");
    reginfo[entrycnt].inst_name = "vmov.p";
    gen_full_rand(0xd0000080, &bg_noise[0], 128);
    uint32_t basew = 0xd0000080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmov.p
  entrycnt++;
  { // Tests for instruction vmov.t (Vector copy)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmov.t\n");
    reginfo[entrycnt].inst_name = "vmov.t";
    gen_full_rand(0xd0008000, &bg_noise[0], 128);
    uint32_t basew = 0xd0008000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmov.t
  entrycnt++;
  { // Tests for instruction vmov.q (Vector copy)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmov.q\n");
    reginfo[entrycnt].inst_name = "vmov.q";
    gen_full_rand(0xd0008080, &bg_noise[0], 128);
    uint32_t basew = 0xd0008080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmov.q
  entrycnt++;
  { // Tests for instruction vabs.s (Absolute value)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vabs.s\n");
    reginfo[entrycnt].inst_name = "vabs.s";
    gen_full_rand(0xd0010000, &bg_noise[0], 128);
    uint32_t basew = 0xd0010000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vabs.s
  entrycnt++;
  { // Tests for instruction vabs.p (Absolute value)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vabs.p\n");
    reginfo[entrycnt].inst_name = "vabs.p";
    gen_full_rand(0xd0010080, &bg_noise[0], 128);
    uint32_t basew = 0xd0010080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vabs.p
  entrycnt++;
  { // Tests for instruction vabs.t (Absolute value)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vabs.t\n");
    reginfo[entrycnt].inst_name = "vabs.t";
    gen_full_rand(0xd0018000, &bg_noise[0], 128);
    uint32_t basew = 0xd0018000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vabs.t
  entrycnt++;
  { // Tests for instruction vabs.q (Absolute value)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vabs.q\n");
    reginfo[entrycnt].inst_name = "vabs.q";
    gen_full_rand(0xd0018080, &bg_noise[0], 128);
    uint32_t basew = 0xd0018080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vabs.q
  entrycnt++;
  { // Tests for instruction vneg.s (Floating point negation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vneg.s\n");
    reginfo[entrycnt].inst_name = "vneg.s";
    gen_full_rand(0xd0020000, &bg_noise[0], 128);
    uint32_t basew = 0xd0020000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vneg.s
  entrycnt++;
  { // Tests for instruction vneg.p (Floating point negation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vneg.p\n");
    reginfo[entrycnt].inst_name = "vneg.p";
    gen_full_rand(0xd0020080, &bg_noise[0], 128);
    uint32_t basew = 0xd0020080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vneg.p
  entrycnt++;
  { // Tests for instruction vneg.t (Floating point negation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vneg.t\n");
    reginfo[entrycnt].inst_name = "vneg.t";
    gen_full_rand(0xd0028000, &bg_noise[0], 128);
    uint32_t basew = 0xd0028000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vneg.t
  entrycnt++;
  { // Tests for instruction vneg.q (Floating point negation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vneg.q\n");
    reginfo[entrycnt].inst_name = "vneg.q";
    gen_full_rand(0xd0028080, &bg_noise[0], 128);
    uint32_t basew = 0xd0028080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vneg.q
  entrycnt++;
  { // Tests for instruction vsat0.s (Saturate float to 0..1)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsat0.s\n");
    reginfo[entrycnt].inst_name = "vsat0.s";
    gen_full_rand(0xd0040000, &bg_noise[0], 128);
    uint32_t basew = 0xd0040000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsat0.s
  entrycnt++;
  { // Tests for instruction vsat0.p (Saturate float to 0..1)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsat0.p\n");
    reginfo[entrycnt].inst_name = "vsat0.p";
    gen_full_rand(0xd0040080, &bg_noise[0], 128);
    uint32_t basew = 0xd0040080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsat0.p
  entrycnt++;
  { // Tests for instruction vsat0.t (Saturate float to 0..1)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsat0.t\n");
    reginfo[entrycnt].inst_name = "vsat0.t";
    gen_full_rand(0xd0048000, &bg_noise[0], 128);
    uint32_t basew = 0xd0048000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsat0.t
  entrycnt++;
  { // Tests for instruction vsat0.q (Saturate float to 0..1)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsat0.q\n");
    reginfo[entrycnt].inst_name = "vsat0.q";
    gen_full_rand(0xd0048080, &bg_noise[0], 128);
    uint32_t basew = 0xd0048080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsat0.q
  entrycnt++;
  { // Tests for instruction vsat1.s (Saturate float to -1..1)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsat1.s\n");
    reginfo[entrycnt].inst_name = "vsat1.s";
    gen_full_rand(0xd0050000, &bg_noise[0], 128);
    uint32_t basew = 0xd0050000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsat1.s
  entrycnt++;
  { // Tests for instruction vsat1.p (Saturate float to -1..1)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsat1.p\n");
    reginfo[entrycnt].inst_name = "vsat1.p";
    gen_full_rand(0xd0050080, &bg_noise[0], 128);
    uint32_t basew = 0xd0050080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsat1.p
  entrycnt++;
  { // Tests for instruction vsat1.t (Saturate float to -1..1)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsat1.t\n");
    reginfo[entrycnt].inst_name = "vsat1.t";
    gen_full_rand(0xd0058000, &bg_noise[0], 128);
    uint32_t basew = 0xd0058000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsat1.t
  entrycnt++;
  { // Tests for instruction vsat1.q (Saturate float to -1..1)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsat1.q\n");
    reginfo[entrycnt].inst_name = "vsat1.q";
    gen_full_rand(0xd0058080, &bg_noise[0], 128);
    uint32_t basew = 0xd0058080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsat1.q
  entrycnt++;
  { // Tests for instruction vrcp.s (Reciprocate elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrcp.s\n");
    reginfo[entrycnt].inst_name = "vrcp.s";
    gen_full_rand(0xd0100000, &bg_noise[0], 128);
    uint32_t basew = 0xd0100000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrcp.s
  entrycnt++;
  { // Tests for instruction vrcp.p (Reciprocate elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrcp.p\n");
    reginfo[entrycnt].inst_name = "vrcp.p";
    gen_full_rand(0xd0100080, &bg_noise[0], 128);
    uint32_t basew = 0xd0100080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrcp.p
  entrycnt++;
  { // Tests for instruction vrcp.t (Reciprocate elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrcp.t\n");
    reginfo[entrycnt].inst_name = "vrcp.t";
    gen_full_rand(0xd0108000, &bg_noise[0], 128);
    uint32_t basew = 0xd0108000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrcp.t
  entrycnt++;
  { // Tests for instruction vrcp.q (Reciprocate elements)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrcp.q\n");
    reginfo[entrycnt].inst_name = "vrcp.q";
    gen_full_rand(0xd0108080, &bg_noise[0], 128);
    uint32_t basew = 0xd0108080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrcp.q
  entrycnt++;
  { // Tests for instruction vrsq.s (Reciprocal square root)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrsq.s\n");
    reginfo[entrycnt].inst_name = "vrsq.s";
    gen_full_rand(0xd0110000, &bg_noise[0], 128);
    uint32_t basew = 0xd0110000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrsq.s
  entrycnt++;
  { // Tests for instruction vrsq.p (Reciprocal square root)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrsq.p\n");
    reginfo[entrycnt].inst_name = "vrsq.p";
    gen_full_rand(0xd0110080, &bg_noise[0], 128);
    uint32_t basew = 0xd0110080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrsq.p
  entrycnt++;
  { // Tests for instruction vrsq.t (Reciprocal square root)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrsq.t\n");
    reginfo[entrycnt].inst_name = "vrsq.t";
    gen_full_rand(0xd0118000, &bg_noise[0], 128);
    uint32_t basew = 0xd0118000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrsq.t
  entrycnt++;
  { // Tests for instruction vrsq.q (Reciprocal square root)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrsq.q\n");
    reginfo[entrycnt].inst_name = "vrsq.q";
    gen_full_rand(0xd0118080, &bg_noise[0], 128);
    uint32_t basew = 0xd0118080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrsq.q
  entrycnt++;
  { // Tests for instruction vsin.s (Sine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsin.s\n");
    reginfo[entrycnt].inst_name = "vsin.s";
    gen_full_rand(0xd0120000, &bg_noise[0], 128);
    uint32_t basew = 0xd0120000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsin.s
  entrycnt++;
  { // Tests for instruction vsin.p (Sine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsin.p\n");
    reginfo[entrycnt].inst_name = "vsin.p";
    gen_full_rand(0xd0120080, &bg_noise[0], 128);
    uint32_t basew = 0xd0120080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsin.p
  entrycnt++;
  { // Tests for instruction vsin.t (Sine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsin.t\n");
    reginfo[entrycnt].inst_name = "vsin.t";
    gen_full_rand(0xd0128000, &bg_noise[0], 128);
    uint32_t basew = 0xd0128000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsin.t
  entrycnt++;
  { // Tests for instruction vsin.q (Sine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsin.q\n");
    reginfo[entrycnt].inst_name = "vsin.q";
    gen_full_rand(0xd0128080, &bg_noise[0], 128);
    uint32_t basew = 0xd0128080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsin.q
  entrycnt++;
  { // Tests for instruction vcos.s (Cosine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vcos.s\n");
    reginfo[entrycnt].inst_name = "vcos.s";
    gen_full_rand(0xd0130000, &bg_noise[0], 128);
    uint32_t basew = 0xd0130000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vcos.s
  entrycnt++;
  { // Tests for instruction vcos.p (Cosine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vcos.p\n");
    reginfo[entrycnt].inst_name = "vcos.p";
    gen_full_rand(0xd0130080, &bg_noise[0], 128);
    uint32_t basew = 0xd0130080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vcos.p
  entrycnt++;
  { // Tests for instruction vcos.t (Cosine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vcos.t\n");
    reginfo[entrycnt].inst_name = "vcos.t";
    gen_full_rand(0xd0138000, &bg_noise[0], 128);
    uint32_t basew = 0xd0138000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vcos.t
  entrycnt++;
  { // Tests for instruction vcos.q (Cosine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vcos.q\n");
    reginfo[entrycnt].inst_name = "vcos.q";
    gen_full_rand(0xd0138080, &bg_noise[0], 128);
    uint32_t basew = 0xd0138080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vcos.q
  entrycnt++;
  { // Tests for instruction vexp2.s (Base-2 exponentiation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vexp2.s\n");
    reginfo[entrycnt].inst_name = "vexp2.s";
    gen_full_rand(0xd0140000, &bg_noise[0], 128);
    uint32_t basew = 0xd0140000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vexp2.s
  entrycnt++;
  { // Tests for instruction vexp2.p (Base-2 exponentiation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vexp2.p\n");
    reginfo[entrycnt].inst_name = "vexp2.p";
    gen_full_rand(0xd0140080, &bg_noise[0], 128);
    uint32_t basew = 0xd0140080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vexp2.p
  entrycnt++;
  { // Tests for instruction vexp2.t (Base-2 exponentiation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vexp2.t\n");
    reginfo[entrycnt].inst_name = "vexp2.t";
    gen_full_rand(0xd0148000, &bg_noise[0], 128);
    uint32_t basew = 0xd0148000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vexp2.t
  entrycnt++;
  { // Tests for instruction vexp2.q (Base-2 exponentiation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vexp2.q\n");
    reginfo[entrycnt].inst_name = "vexp2.q";
    gen_full_rand(0xd0148080, &bg_noise[0], 128);
    uint32_t basew = 0xd0148080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vexp2.q
  entrycnt++;
  { // Tests for instruction vlog2.s (Base-2 logarithm)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vlog2.s\n");
    reginfo[entrycnt].inst_name = "vlog2.s";
    gen_full_rand(0xd0150000, &bg_noise[0], 128);
    uint32_t basew = 0xd0150000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vlog2.s
  entrycnt++;
  { // Tests for instruction vlog2.p (Base-2 logarithm)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vlog2.p\n");
    reginfo[entrycnt].inst_name = "vlog2.p";
    gen_full_rand(0xd0150080, &bg_noise[0], 128);
    uint32_t basew = 0xd0150080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vlog2.p
  entrycnt++;
  { // Tests for instruction vlog2.t (Base-2 logarithm)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vlog2.t\n");
    reginfo[entrycnt].inst_name = "vlog2.t";
    gen_full_rand(0xd0158000, &bg_noise[0], 128);
    uint32_t basew = 0xd0158000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vlog2.t
  entrycnt++;
  { // Tests for instruction vlog2.q (Base-2 logarithm)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vlog2.q\n");
    reginfo[entrycnt].inst_name = "vlog2.q";
    gen_full_rand(0xd0158080, &bg_noise[0], 128);
    uint32_t basew = 0xd0158080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vlog2.q
  entrycnt++;
  { // Tests for instruction vlgb.s (LogB calculation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vlgb.s\n");
    reginfo[entrycnt].inst_name = "vlgb.s";
    gen_full_rand(0xd0370000, &bg_noise[0], 128);
    uint32_t basew = 0xd0370000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vlgb.s
  entrycnt++;
  { // Tests for instruction vsbz.s (Reset exponent scale)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsbz.s\n");
    reginfo[entrycnt].inst_name = "vsbz.s";
    gen_full_rand(0xd0360000, &bg_noise[0], 128);
    uint32_t basew = 0xd0360000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[1];
      gen_inputs_u32(i >> 0, &rs_ref[0], 1);
      {
        unsigned int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsbz.s
  entrycnt++;
  { // Tests for instruction vwbn.s (Floating point modulus)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vwbn.s\n");
    reginfo[entrycnt].inst_name = "vwbn.s";
    gen_full_rand(0xd3000000, &bg_noise[0], 128);
    uint32_t basew = 0xd3000000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[1];
      gen_inputs_u32(i >> 0, &rs_ref[0], 1);
      const unsigned int immseq[][1] = {
          {1},   {254}, {78},  {95},  {106}, {85},  {183}, {239}, {225}, {49},
          {128}, {212}, {98},  {114}, {239}, {98},  {3},   {117}, {159}, {71},
          {166}, {73},  {207}, {58},  {132}, {187}, {162}, {41},  {16},  {204},
          {28},  {121}, {33},  {50},  {185}, {170}, {39},  {252}, {254}, {98},
          {208}, {93},  {8},   {171}, {185}, {159}, {252}, {216}, {155}, {102},
          {195}, {56},  {114}, {12},  {241}, {134}, {73},  {131}, {196}, {188},
          {60},  {45},  {77},  {91},  {119}, {163},
      };
      for (unsigned imcnt = 0; imcnt < 66; imcnt++) {
        basew = (basew & (~(0xff << 16))) | (immseq[imcnt][0] << 16);
        unsigned int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vwbn.s
  entrycnt++;
  { // Tests for instruction vsqrt.s (Square root)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsqrt.s\n");
    reginfo[entrycnt].inst_name = "vsqrt.s";
    gen_full_rand(0xd0160000, &bg_noise[0], 128);
    uint32_t basew = 0xd0160000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsqrt.s
  entrycnt++;
  { // Tests for instruction vsqrt.p (Square root)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsqrt.p\n");
    reginfo[entrycnt].inst_name = "vsqrt.p";
    gen_full_rand(0xd0160080, &bg_noise[0], 128);
    uint32_t basew = 0xd0160080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsqrt.p
  entrycnt++;
  { // Tests for instruction vsqrt.t (Square root)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsqrt.t\n");
    reginfo[entrycnt].inst_name = "vsqrt.t";
    gen_full_rand(0xd0168000, &bg_noise[0], 128);
    uint32_t basew = 0xd0168000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsqrt.t
  entrycnt++;
  { // Tests for instruction vsqrt.q (Square root)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsqrt.q\n");
    reginfo[entrycnt].inst_name = "vsqrt.q";
    gen_full_rand(0xd0168080, &bg_noise[0], 128);
    uint32_t basew = 0xd0168080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsqrt.q
  entrycnt++;
  { // Tests for instruction vasin.s (Arc sine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vasin.s\n");
    reginfo[entrycnt].inst_name = "vasin.s";
    gen_full_rand(0xd0170000, &bg_noise[0], 128);
    uint32_t basew = 0xd0170000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vasin.s
  entrycnt++;
  { // Tests for instruction vasin.p (Arc sine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vasin.p\n");
    reginfo[entrycnt].inst_name = "vasin.p";
    gen_full_rand(0xd0170080, &bg_noise[0], 128);
    uint32_t basew = 0xd0170080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vasin.p
  entrycnt++;
  { // Tests for instruction vasin.t (Arc sine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vasin.t\n");
    reginfo[entrycnt].inst_name = "vasin.t";
    gen_full_rand(0xd0178000, &bg_noise[0], 128);
    uint32_t basew = 0xd0178000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vasin.t
  entrycnt++;
  { // Tests for instruction vasin.q (Arc sine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vasin.q\n");
    reginfo[entrycnt].inst_name = "vasin.q";
    gen_full_rand(0xd0178080, &bg_noise[0], 128);
    uint32_t basew = 0xd0178080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vasin.q
  entrycnt++;
  { // Tests for instruction vnrcp.s (Negative reciprocal)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vnrcp.s\n");
    reginfo[entrycnt].inst_name = "vnrcp.s";
    gen_full_rand(0xd0180000, &bg_noise[0], 128);
    uint32_t basew = 0xd0180000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vnrcp.s
  entrycnt++;
  { // Tests for instruction vnrcp.p (Negative reciprocal)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vnrcp.p\n");
    reginfo[entrycnt].inst_name = "vnrcp.p";
    gen_full_rand(0xd0180080, &bg_noise[0], 128);
    uint32_t basew = 0xd0180080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vnrcp.p
  entrycnt++;
  { // Tests for instruction vnrcp.t (Negative reciprocal)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vnrcp.t\n");
    reginfo[entrycnt].inst_name = "vnrcp.t";
    gen_full_rand(0xd0188000, &bg_noise[0], 128);
    uint32_t basew = 0xd0188000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vnrcp.t
  entrycnt++;
  { // Tests for instruction vnrcp.q (Negative reciprocal)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vnrcp.q\n");
    reginfo[entrycnt].inst_name = "vnrcp.q";
    gen_full_rand(0xd0188080, &bg_noise[0], 128);
    uint32_t basew = 0xd0188080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vnrcp.q
  entrycnt++;
  { // Tests for instruction vnsin.s (Negative sine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vnsin.s\n");
    reginfo[entrycnt].inst_name = "vnsin.s";
    gen_full_rand(0xd01a0000, &bg_noise[0], 128);
    uint32_t basew = 0xd01a0000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vnsin.s
  entrycnt++;
  { // Tests for instruction vnsin.p (Negative sine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vnsin.p\n");
    reginfo[entrycnt].inst_name = "vnsin.p";
    gen_full_rand(0xd01a0080, &bg_noise[0], 128);
    uint32_t basew = 0xd01a0080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vnsin.p
  entrycnt++;
  { // Tests for instruction vnsin.t (Negative sine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vnsin.t\n");
    reginfo[entrycnt].inst_name = "vnsin.t";
    gen_full_rand(0xd01a8000, &bg_noise[0], 128);
    uint32_t basew = 0xd01a8000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vnsin.t
  entrycnt++;
  { // Tests for instruction vnsin.q (Negative sine function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vnsin.q\n");
    reginfo[entrycnt].inst_name = "vnsin.q";
    gen_full_rand(0xd01a8080, &bg_noise[0], 128);
    uint32_t basew = 0xd01a8080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vnsin.q
  entrycnt++;
  { // Tests for instruction vrexp2.s (Base-2 negative exponentiation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrexp2.s\n");
    reginfo[entrycnt].inst_name = "vrexp2.s";
    gen_full_rand(0xd01c0000, &bg_noise[0], 128);
    uint32_t basew = 0xd01c0000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrexp2.s
  entrycnt++;
  { // Tests for instruction vrexp2.p (Base-2 negative exponentiation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrexp2.p\n");
    reginfo[entrycnt].inst_name = "vrexp2.p";
    gen_full_rand(0xd01c0080, &bg_noise[0], 128);
    uint32_t basew = 0xd01c0080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrexp2.p
  entrycnt++;
  { // Tests for instruction vrexp2.t (Base-2 negative exponentiation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrexp2.t\n");
    reginfo[entrycnt].inst_name = "vrexp2.t";
    gen_full_rand(0xd01c8000, &bg_noise[0], 128);
    uint32_t basew = 0xd01c8000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrexp2.t
  entrycnt++;
  { // Tests for instruction vrexp2.q (Base-2 negative exponentiation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrexp2.q\n");
    reginfo[entrycnt].inst_name = "vrexp2.q";
    gen_full_rand(0xd01c8080, &bg_noise[0], 128);
    uint32_t basew = 0xd01c8080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrexp2.q
  entrycnt++;
  { // Tests for instruction vsrt1.q (Element min-sort pass #1)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsrt1.q\n");
    reginfo[entrycnt].inst_name = "vsrt1.q";
    gen_full_rand(0xd0408080, &bg_noise[0], 128);
    uint32_t basew = 0xd0408080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsrt1.q
  entrycnt++;
  { // Tests for instruction vsrt2.q (Element min-sort pass #2)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsrt2.q\n");
    reginfo[entrycnt].inst_name = "vsrt2.q";
    gen_full_rand(0xd0418080, &bg_noise[0], 128);
    uint32_t basew = 0xd0418080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsrt2.q
  entrycnt++;
  { // Tests for instruction vsrt3.q (Element max-sort pass #1)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsrt3.q\n");
    reginfo[entrycnt].inst_name = "vsrt3.q";
    gen_full_rand(0xd0488080, &bg_noise[0], 128);
    uint32_t basew = 0xd0488080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsrt3.q
  entrycnt++;
  { // Tests for instruction vsrt4.q (Element max-sort pass #2)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsrt4.q\n");
    reginfo[entrycnt].inst_name = "vsrt4.q";
    gen_full_rand(0xd0498080, &bg_noise[0], 128);
    uint32_t basew = 0xd0498080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsrt4.q
  entrycnt++;
  { // Tests for instruction vbfy1.p (Butterfly function #1)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vbfy1.p\n");
    reginfo[entrycnt].inst_name = "vbfy1.p";
    gen_full_rand(0xd0420080, &bg_noise[0], 128);
    uint32_t basew = 0xd0420080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vbfy1.p
  entrycnt++;
  { // Tests for instruction vbfy1.q (Butterfly function #1)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vbfy1.q\n");
    reginfo[entrycnt].inst_name = "vbfy1.q";
    gen_full_rand(0xd0428080, &bg_noise[0], 128);
    uint32_t basew = 0xd0428080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vbfy1.q
  entrycnt++;
  { // Tests for instruction vbfy2.q (Butterfly function #2)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vbfy2.q\n");
    reginfo[entrycnt].inst_name = "vbfy2.q";
    gen_full_rand(0xd0438080, &bg_noise[0], 128);
    uint32_t basew = 0xd0438080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vbfy2.q
  entrycnt++;
  { // Tests for instruction vsgn.s (Sign function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsgn.s\n");
    reginfo[entrycnt].inst_name = "vsgn.s";
    gen_full_rand(0xd04a0000, &bg_noise[0], 128);
    uint32_t basew = 0xd04a0000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsgn.s
  entrycnt++;
  { // Tests for instruction vsgn.p (Sign function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsgn.p\n");
    reginfo[entrycnt].inst_name = "vsgn.p";
    gen_full_rand(0xd04a0080, &bg_noise[0], 128);
    uint32_t basew = 0xd04a0080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsgn.p
  entrycnt++;
  { // Tests for instruction vsgn.t (Sign function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsgn.t\n");
    reginfo[entrycnt].inst_name = "vsgn.t";
    gen_full_rand(0xd04a8000, &bg_noise[0], 128);
    uint32_t basew = 0xd04a8000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsgn.t
  entrycnt++;
  { // Tests for instruction vsgn.q (Sign function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsgn.q\n");
    reginfo[entrycnt].inst_name = "vsgn.q";
    gen_full_rand(0xd04a8080, &bg_noise[0], 128);
    uint32_t basew = 0xd04a8080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsgn.q
  entrycnt++;
  { // Tests for instruction vocp.s (One complement function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vocp.s\n");
    reginfo[entrycnt].inst_name = "vocp.s";
    gen_full_rand(0xd0440000, &bg_noise[0], 128);
    uint32_t basew = 0xd0440000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vocp.s
  entrycnt++;
  { // Tests for instruction vocp.p (One complement function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vocp.p\n");
    reginfo[entrycnt].inst_name = "vocp.p";
    gen_full_rand(0xd0440080, &bg_noise[0], 128);
    uint32_t basew = 0xd0440080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vocp.p
  entrycnt++;
  { // Tests for instruction vocp.t (One complement function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vocp.t\n");
    reginfo[entrycnt].inst_name = "vocp.t";
    gen_full_rand(0xd0448000, &bg_noise[0], 128);
    uint32_t basew = 0xd0448000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vocp.t
  entrycnt++;
  { // Tests for instruction vocp.q (One complement function)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vocp.q\n");
    reginfo[entrycnt].inst_name = "vocp.q";
    gen_full_rand(0xd0448080, &bg_noise[0], 128);
    uint32_t basew = 0xd0448080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vocp.q
  entrycnt++;
  { // Tests for instruction vi2f.s (Integer to float with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vi2f.s\n");
    reginfo[entrycnt].inst_name = "vi2f.s";
    gen_full_rand(0xd2800000, &bg_noise[0], 128);
    uint32_t basew = 0xd2800000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      int rs_ref[1];
      gen_inputs_s32(i >> 0, &rs_ref[0], 1);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vi2f.s
  entrycnt++;
  { // Tests for instruction vi2f.p (Integer to float with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vi2f.p\n");
    reginfo[entrycnt].inst_name = "vi2f.p";
    gen_full_rand(0xd2800080, &bg_noise[0], 128);
    uint32_t basew = 0xd2800080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      int rs_ref[2];
      gen_inputs_s32(i >> 0, &rs_ref[0], 2);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vi2f.p
  entrycnt++;
  { // Tests for instruction vi2f.t (Integer to float with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vi2f.t\n");
    reginfo[entrycnt].inst_name = "vi2f.t";
    gen_full_rand(0xd2808000, &bg_noise[0], 128);
    uint32_t basew = 0xd2808000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      int rs_ref[3];
      gen_inputs_s32(i >> 0, &rs_ref[0], 3);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vi2f.t
  entrycnt++;
  { // Tests for instruction vi2f.q (Integer to float with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vi2f.q\n");
    reginfo[entrycnt].inst_name = "vi2f.q";
    gen_full_rand(0xd2808080, &bg_noise[0], 128);
    uint32_t basew = 0xd2808080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      int rs_ref[4];
      gen_inputs_s32(i >> 0, &rs_ref[0], 4);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vi2f.q
  entrycnt++;
  { // Tests for instruction vf2in.s (Float to integer round-to-nearest with
    // scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2in.s\n");
    reginfo[entrycnt].inst_name = "vf2in.s";
    gen_full_rand(0xd2000000, &bg_noise[0], 128);
    uint32_t basew = 0xd2000000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2in.s
  entrycnt++;
  { // Tests for instruction vf2in.p (Float to integer round-to-nearest with
    // scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2in.p\n");
    reginfo[entrycnt].inst_name = "vf2in.p";
    gen_full_rand(0xd2000080, &bg_noise[0], 128);
    uint32_t basew = 0xd2000080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2in.p
  entrycnt++;
  { // Tests for instruction vf2in.t (Float to integer round-to-nearest with
    // scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2in.t\n");
    reginfo[entrycnt].inst_name = "vf2in.t";
    gen_full_rand(0xd2008000, &bg_noise[0], 128);
    uint32_t basew = 0xd2008000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2in.t
  entrycnt++;
  { // Tests for instruction vf2in.q (Float to integer round-to-nearest with
    // scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2in.q\n");
    reginfo[entrycnt].inst_name = "vf2in.q";
    gen_full_rand(0xd2008080, &bg_noise[0], 128);
    uint32_t basew = 0xd2008080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2in.q
  entrycnt++;
  { // Tests for instruction vf2iz.s (Float to integer truncation with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2iz.s\n");
    reginfo[entrycnt].inst_name = "vf2iz.s";
    gen_full_rand(0xd2200000, &bg_noise[0], 128);
    uint32_t basew = 0xd2200000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2iz.s
  entrycnt++;
  { // Tests for instruction vf2iz.p (Float to integer truncation with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2iz.p\n");
    reginfo[entrycnt].inst_name = "vf2iz.p";
    gen_full_rand(0xd2200080, &bg_noise[0], 128);
    uint32_t basew = 0xd2200080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2iz.p
  entrycnt++;
  { // Tests for instruction vf2iz.t (Float to integer truncation with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2iz.t\n");
    reginfo[entrycnt].inst_name = "vf2iz.t";
    gen_full_rand(0xd2208000, &bg_noise[0], 128);
    uint32_t basew = 0xd2208000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2iz.t
  entrycnt++;
  { // Tests for instruction vf2iz.q (Float to integer truncation with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2iz.q\n");
    reginfo[entrycnt].inst_name = "vf2iz.q";
    gen_full_rand(0xd2208080, &bg_noise[0], 128);
    uint32_t basew = 0xd2208080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2iz.q
  entrycnt++;
  { // Tests for instruction vf2iu.s (Float to integer round-up with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2iu.s\n");
    reginfo[entrycnt].inst_name = "vf2iu.s";
    gen_full_rand(0xd2400000, &bg_noise[0], 128);
    uint32_t basew = 0xd2400000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2iu.s
  entrycnt++;
  { // Tests for instruction vf2iu.p (Float to integer round-up with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2iu.p\n");
    reginfo[entrycnt].inst_name = "vf2iu.p";
    gen_full_rand(0xd2400080, &bg_noise[0], 128);
    uint32_t basew = 0xd2400080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2iu.p
  entrycnt++;
  { // Tests for instruction vf2iu.t (Float to integer round-up with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2iu.t\n");
    reginfo[entrycnt].inst_name = "vf2iu.t";
    gen_full_rand(0xd2408000, &bg_noise[0], 128);
    uint32_t basew = 0xd2408000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2iu.t
  entrycnt++;
  { // Tests for instruction vf2iu.q (Float to integer round-up with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2iu.q\n");
    reginfo[entrycnt].inst_name = "vf2iu.q";
    gen_full_rand(0xd2408080, &bg_noise[0], 128);
    uint32_t basew = 0xd2408080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2iu.q
  entrycnt++;
  { // Tests for instruction vf2id.s (Float to integer round-down with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2id.s\n");
    reginfo[entrycnt].inst_name = "vf2id.s";
    gen_full_rand(0xd2600000, &bg_noise[0], 128);
    uint32_t basew = 0xd2600000;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2id.s
  entrycnt++;
  { // Tests for instruction vf2id.p (Float to integer round-down with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2id.p\n");
    reginfo[entrycnt].inst_name = "vf2id.p";
    gen_full_rand(0xd2600080, &bg_noise[0], 128);
    uint32_t basew = 0xd2600080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2id.p
  entrycnt++;
  { // Tests for instruction vf2id.t (Float to integer round-down with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2id.t\n");
    reginfo[entrycnt].inst_name = "vf2id.t";
    gen_full_rand(0xd2608000, &bg_noise[0], 128);
    uint32_t basew = 0xd2608000;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[4 + 1] = 0xe8840005;
        instb[5 + 1] = 0xe884000a;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2id.t
  entrycnt++;
  { // Tests for instruction vf2id.q (Float to integer round-down with scaling)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2id.q\n");
    reginfo[entrycnt].inst_name = "vf2id.q";
    gen_full_rand(0xd2608080, &bg_noise[0], 128);
    uint32_t basew = 0xd2608080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        int rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[6 + 1] = 0xe884000a;
        instb[7 + 1] = 0xe884000f;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2id.q
  entrycnt++;
  { // Tests for instruction vrot.p (Rotation matrix row calculation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrot.p\n");
    reginfo[entrycnt].inst_name = "vrot.p";
    gen_full_rand(0xf3a00080, &bg_noise[0], 128);
    uint32_t basew = 0xf3a00080;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[2 + 1] = 0xe8840005;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_single1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_single1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_single1[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_single1[reg_rs], reg_mask_single1[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_single1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrot.p
  entrycnt++;
  { // Tests for instruction vrot.t (Rotation matrix row calculation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrot.t\n");
    reginfo[entrycnt].inst_name = "vrot.t";
    gen_full_rand(0xf3a08000, &bg_noise[0], 128);
    uint32_t basew = 0xf3a08000;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[2 + 1] = 0xe8840005;
        instb[3 + 1] = 0xe884000a;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_single1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_single1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
            for (unsigned p = 0; p < 3; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 3)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_single1[reg_rs], reg_mask_vector3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_single1[reg_rs], reg_mask_single1[reg_rs],
                               rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_single1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrot.t
  entrycnt++;
  { // Tests for instruction vrot.q (Rotation matrix row calculation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vrot.q\n");
    reginfo[entrycnt].inst_name = "vrot.q";
    gen_full_rand(0xf3a08080, &bg_noise[0], 128);
    uint32_t basew = 0xf3a08080;
    instb[6] = 0x03e00008; // jr ra
    instb[7] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      const unsigned int immseq[][1] = {
          {0},  {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20}, {21},
          {22}, {23}, {24}, {25}, {26}, {27}, {28}, {29}, {30}, {31},
      };
      for (unsigned imcnt = 0; imcnt < 32; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[2 + 1] = 0xe8840005;
        instb[3 + 1] = 0xe884000a;
        instb[4 + 1] = 0xe884000f;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_single1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_single1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_single1[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_single1[reg_rs], reg_mask_single1[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_single1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vrot.q
  entrycnt++;
  { // Tests for instruction vsocp.s (One complement with saturation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsocp.s\n");
    reginfo[entrycnt].inst_name = "vsocp.s";
    gen_full_rand(0xd0450000, &bg_noise[0], 128);
    uint32_t basew = 0xd0450000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[1];
      gen_inputs_f32(i >> 0, &rs_ref[0], 1);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[2 + 1] = 0xe8840005;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsocp.s
  entrycnt++;
  { // Tests for instruction vsocp.p (One complement with saturation)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vsocp.p\n");
    reginfo[entrycnt].inst_name = "vsocp.p";
    gen_full_rand(0xd0450080, &bg_noise[0], 128);
    uint32_t basew = 0xd0450080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[4 + 1] = 0xe884000a;
        instb[5 + 1] = 0xe884000f;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vsocp.p
  entrycnt++;
  { // Tests for instruction vavg.p (Calculate element average)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vavg.p\n");
    reginfo[entrycnt].inst_name = "vavg.p";
    gen_full_rand(0xd0470080, &bg_noise[0], 128);
    uint32_t basew = 0xd0470080;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_single1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_single1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vavg.p
  entrycnt++;
  { // Tests for instruction vavg.t (Calculate element average)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vavg.t\n");
    reginfo[entrycnt].inst_name = "vavg.t";
    gen_full_rand(0xd0478000, &bg_noise[0], 128);
    uint32_t basew = 0xd0478000;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_single1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_single1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vavg.t
  entrycnt++;
  { // Tests for instruction vavg.q (Calculate element average)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vavg.q\n");
    reginfo[entrycnt].inst_name = "vavg.q";
    gen_full_rand(0xd0478080, &bg_noise[0], 128);
    uint32_t basew = 0xd0478080;
    instb[6] = 0x03e00008; // jr ra
    instb[7] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_single1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_single1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vavg.q
  entrycnt++;
  { // Tests for instruction vfad.p (Calculate element sum)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vfad.p\n");
    reginfo[entrycnt].inst_name = "vfad.p";
    gen_full_rand(0xd0460080, &bg_noise[0], 128);
    uint32_t basew = 0xd0460080;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[2];
      gen_inputs_f32(i >> 0, &rs_ref[0], 2);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_single1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_single1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vfad.p
  entrycnt++;
  { // Tests for instruction vfad.t (Calculate element sum)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vfad.t\n");
    reginfo[entrycnt].inst_name = "vfad.t";
    gen_full_rand(0xd0468000, &bg_noise[0], 128);
    uint32_t basew = 0xd0468000;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[3];
      gen_inputs_f32(i >> 0, &rs_ref[0], 3);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3 + 1] = 0xe8840000;
        instb[3] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector3[reg_rs] << 8);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[3 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_single1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[3] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector3[reg_rs], reg_mask_single1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector3[reg_rs], reg_mask_vector3[reg_rs],
                               rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vfad.t
  entrycnt++;
  { // Tests for instruction vfad.q (Calculate element sum)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vfad.q\n");
    reginfo[entrycnt].inst_name = "vfad.q";
    gen_full_rand(0xd0468080, &bg_noise[0], 128);
    uint32_t basew = 0xd0468080;
    instb[6] = 0x03e00008; // jr ra
    instb[7] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_single1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_single1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vfad.q
  entrycnt++;
  { // Tests for instruction vzero.s (Clear vector to zero)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vzero.s\n");
    reginfo[entrycnt].inst_name = "vzero.s";
    gen_full_rand(0xd0060000, &bg_noise[0], 128);
    uint32_t basew = 0xd0060000;
    instb[2] = 0x03e00008; // jr ra
    instb[3] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_vector1[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 1)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vzero.s
  entrycnt++;
  { // Tests for instruction vzero.p (Clear vector to zero)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vzero.p\n");
    reginfo[entrycnt].inst_name = "vzero.p";
    gen_full_rand(0xd0060080, &bg_noise[0], 128);
    uint32_t basew = 0xd0060080;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8800005;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_vector2[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 2)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vzero.p
  entrycnt++;
  { // Tests for instruction vzero.t (Clear vector to zero)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vzero.t\n");
    reginfo[entrycnt].inst_name = "vzero.t";
    gen_full_rand(0xd0068000, &bg_noise[0], 128);
    uint32_t basew = 0xd0068000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8800005;
        instb[2 + 1] = 0xe880000a;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_vector3[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 3)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vzero.t
  entrycnt++;
  { // Tests for instruction vzero.q (Clear vector to zero)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vzero.q\n");
    reginfo[entrycnt].inst_name = "vzero.q";
    gen_full_rand(0xd0068080, &bg_noise[0], 128);
    uint32_t basew = 0xd0068080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8800005;
        instb[2 + 1] = 0xe880000a;
        instb[3 + 1] = 0xe880000f;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_vector4[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 4)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vzero.q
  entrycnt++;
  { // Tests for instruction vone.s (Clear vector to one)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vone.s\n");
    reginfo[entrycnt].inst_name = "vone.s";
    gen_full_rand(0xd0070000, &bg_noise[0], 128);
    uint32_t basew = 0xd0070000;
    instb[2] = 0x03e00008; // jr ra
    instb[3] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_vector1[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 1)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vone.s
  entrycnt++;
  { // Tests for instruction vone.p (Clear vector to one)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vone.p\n");
    reginfo[entrycnt].inst_name = "vone.p";
    gen_full_rand(0xd0070080, &bg_noise[0], 128);
    uint32_t basew = 0xd0070080;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8800005;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_vector2[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 2)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vone.p
  entrycnt++;
  { // Tests for instruction vone.t (Clear vector to one)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vone.t\n");
    reginfo[entrycnt].inst_name = "vone.t";
    gen_full_rand(0xd0078000, &bg_noise[0], 128);
    uint32_t basew = 0xd0078000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8800005;
        instb[2 + 1] = 0xe880000a;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_vector3[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 3)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vone.t
  entrycnt++;
  { // Tests for instruction vone.q (Clear vector to one)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vone.q\n");
    reginfo[entrycnt].inst_name = "vone.q";
    gen_full_rand(0xd0078080, &bg_noise[0], 128);
    uint32_t basew = 0xd0078080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8800005;
        instb[2 + 1] = 0xe880000a;
        instb[3 + 1] = 0xe880000f;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_vector4[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 4)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vone.q
  entrycnt++;
  { // Tests for instruction vmmul.p (Matrix by matrix multiplication)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmmul.p\n");
    reginfo[entrycnt].inst_name = "vmmul.p";
    gen_full_rand(0xf0000080, &bg_noise[0], 128);
    uint32_t basew = 0xf0000080;
    instb[13] = 0x03e00008; // jr ra
    instb[14] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a00009;
        instb[3] = 0xc8a1000d;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c50004;
        instb[6] = 0xc8c40009;
        instb[7] = 0xc8c5000d;
        instb[8 + 1] = 0xe8880000;
        instb[9 + 1] = 0xe8890004;
        instb[10 + 1] = 0xe8880009;
        instb[11 + 1] = 0xe889000d;
        instb[8] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix2[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_matrix2[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_matrix2[reg_rt][p]];
            if (regcol(reg_mask_matrix2[reg_rs], reg_mask_matrix2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_matrix2[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[8 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_matrix2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[8] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_matrix2[reg_rs], reg_mask_matrix2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_matrix2[reg_rs], reg_mask_matrix2[reg_rs],
                    rmap_matrix2[reg_rd], reg_mask_matrix2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_matrix2[reg_rt], reg_mask_matrix2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_matrix2[reg_rt], reg_mask_matrix2[reg_rt],
                    rmap_matrix2[reg_rd], reg_mask_matrix2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_matrix2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_matrix2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmmul.p
  entrycnt++;
  { // Tests for instruction vmmul.t (Matrix by matrix multiplication)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmmul.t\n");
    reginfo[entrycnt].inst_name = "vmmul.t";
    gen_full_rand(0xf0008000, &bg_noise[0], 128);
    uint32_t basew = 0xf0008000;
    instb[28] = 0x03e00008; // jr ra
    instb[29] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[9];
      gen_inputs_f32(i >> 0, &rs_ref[0], 9);
      float rt_ref[9];
      gen_inputs_f32(i >> 2, &rt_ref[0], 9);
      {
        float rd[9], rd_expected[9] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a20008;
        instb[3] = 0xc8a0000d;
        instb[4] = 0xc8a10011;
        instb[5] = 0xc8a20015;
        instb[6] = 0xc8a0001a;
        instb[7] = 0xc8a1001e;
        instb[8] = 0xc8a20022;
        instb[9] = 0xc8c40000;
        instb[10] = 0xc8c50004;
        instb[11] = 0xc8c60008;
        instb[12] = 0xc8c4000d;
        instb[13] = 0xc8c50011;
        instb[14] = 0xc8c60015;
        instb[15] = 0xc8c4001a;
        instb[16] = 0xc8c5001e;
        instb[17] = 0xc8c60022;
        instb[18 + 1] = 0xe8880000;
        instb[19 + 1] = 0xe8890004;
        instb[20 + 1] = 0xe88a0008;
        instb[21 + 1] = 0xe888000d;
        instb[22 + 1] = 0xe8890011;
        instb[23 + 1] = 0xe88a0015;
        instb[24 + 1] = 0xe888001a;
        instb[25 + 1] = 0xe889001e;
        instb[26 + 1] = 0xe88a0022;
        instb[18] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 9); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix3[reg_rs] << 8);
          for (unsigned p = 0; p < 9; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_matrix3[reg_rt] << 16);
            for (unsigned p = 0; p < 9; p++)
              instb[9 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_matrix3[reg_rt][p]];
            if (regcol(reg_mask_matrix3[reg_rs], reg_mask_matrix3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_matrix3[reg_rd] << 0);
              for (unsigned p = 0; p < 9; p++)
                instb[18 + p + 1] =
                    ((4) << 21) | ((p) << 2) |
                    reg_save_inst[subreg_map_matrix3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[18] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 9)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_matrix3[reg_rs], reg_mask_matrix3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_matrix3[reg_rs], reg_mask_matrix3[reg_rs],
                    rmap_matrix3[reg_rd], reg_mask_matrix3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_matrix3[reg_rt], reg_mask_matrix3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_matrix3[reg_rt], reg_mask_matrix3[reg_rt],
                    rmap_matrix3[reg_rd], reg_mask_matrix3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_matrix3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_matrix3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmmul.t
  entrycnt++;
  { // Tests for instruction vmmul.q (Matrix by matrix multiplication)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmmul.q\n");
    reginfo[entrycnt].inst_name = "vmmul.q";
    gen_full_rand(0xf0008080, &bg_noise[0], 128);
    uint32_t basew = 0xf0008080;
    instb[49] = 0x03e00008; // jr ra
    instb[50] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[16];
      gen_inputs_f32(i >> 0, &rs_ref[0], 16);
      float rt_ref[16];
      gen_inputs_f32(i >> 2, &rt_ref[0], 16);
      {
        float rd[16], rd_expected[16] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a20008;
        instb[3] = 0xc8a3000c;
        instb[4] = 0xc8a00011;
        instb[5] = 0xc8a10015;
        instb[6] = 0xc8a20019;
        instb[7] = 0xc8a3001d;
        instb[8] = 0xc8a00022;
        instb[9] = 0xc8a10026;
        instb[10] = 0xc8a2002a;
        instb[11] = 0xc8a3002e;
        instb[12] = 0xc8a00033;
        instb[13] = 0xc8a10037;
        instb[14] = 0xc8a2003b;
        instb[15] = 0xc8a3003f;
        instb[16] = 0xc8c40000;
        instb[17] = 0xc8c50004;
        instb[18] = 0xc8c60008;
        instb[19] = 0xc8c7000c;
        instb[20] = 0xc8c40011;
        instb[21] = 0xc8c50015;
        instb[22] = 0xc8c60019;
        instb[23] = 0xc8c7001d;
        instb[24] = 0xc8c40022;
        instb[25] = 0xc8c50026;
        instb[26] = 0xc8c6002a;
        instb[27] = 0xc8c7002e;
        instb[28] = 0xc8c40033;
        instb[29] = 0xc8c50037;
        instb[30] = 0xc8c6003b;
        instb[31] = 0xc8c7003f;
        instb[32 + 1] = 0xe8880000;
        instb[33 + 1] = 0xe8890004;
        instb[34 + 1] = 0xe88a0008;
        instb[35 + 1] = 0xe88b000c;
        instb[36 + 1] = 0xe8880011;
        instb[37 + 1] = 0xe8890015;
        instb[38 + 1] = 0xe88a0019;
        instb[39 + 1] = 0xe88b001d;
        instb[40 + 1] = 0xe8880022;
        instb[41 + 1] = 0xe8890026;
        instb[42 + 1] = 0xe88a002a;
        instb[43 + 1] = 0xe88b002e;
        instb[44 + 1] = 0xe8880033;
        instb[45 + 1] = 0xe8890037;
        instb[46 + 1] = 0xe88a003b;
        instb[47 + 1] = 0xe88b003f;
        instb[32] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);   // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 16); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 16; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix4[reg_rs] << 8);
          for (unsigned p = 0; p < 16; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 16; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_matrix4[reg_rt] << 16);
            for (unsigned p = 0; p < 16; p++)
              instb[16 + p] = ((6) << 21) | ((p) << 2) |
                              reg_load_inst[subreg_map_matrix4[reg_rt][p]];
            if (regcol(reg_mask_matrix4[reg_rs], reg_mask_matrix4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 16; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_matrix4[reg_rd] << 0);
              for (unsigned p = 0; p < 16; p++)
                instb[32 + p + 1] =
                    ((4) << 21) | ((p) << 2) |
                    reg_save_inst[subreg_map_matrix4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[32] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 16)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_matrix4[reg_rs], reg_mask_matrix4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_matrix4[reg_rs], reg_mask_matrix4[reg_rs],
                    rmap_matrix4[reg_rd], reg_mask_matrix4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_matrix4[reg_rt], reg_mask_matrix4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_matrix4[reg_rt], reg_mask_matrix4[reg_rt],
                    rmap_matrix4[reg_rd], reg_mask_matrix4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_matrix4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_matrix4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmmul.q
  entrycnt++;
  { // Tests for instruction vmscl.p (Matrix scale by single factor)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmscl.p\n");
    reginfo[entrycnt].inst_name = "vmscl.p";
    gen_full_rand(0xf2000080, &bg_noise[0], 128);
    uint32_t basew = 0xf2000080;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a00009;
        instb[3] = 0xc8a1000d;
        instb[4] = 0xc8c40000;
        instb[5 + 1] = 0xe8880000;
        instb[6 + 1] = 0xe8890004;
        instb[7 + 1] = 0xe8880009;
        instb[8 + 1] = 0xe889000d;
        instb[5] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix2[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_single1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_single1[reg_rt][p]];
            if (regcol(reg_mask_matrix2[reg_rs], reg_mask_single1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_matrix2[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[5 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_matrix2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[5] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_matrix2[reg_rs], reg_mask_matrix2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_matrix2[reg_rs], reg_mask_matrix2[reg_rs],
                    rmap_matrix2[reg_rd], reg_mask_matrix2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_single1[reg_rt], reg_mask_matrix2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_single1[reg_rt], reg_mask_single1[reg_rt],
                    rmap_matrix2[reg_rd], reg_mask_matrix2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_matrix2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmscl.p
  entrycnt++;
  { // Tests for instruction vmscl.t (Matrix scale by single factor)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmscl.t\n");
    reginfo[entrycnt].inst_name = "vmscl.t";
    gen_full_rand(0xf2008000, &bg_noise[0], 128);
    uint32_t basew = 0xf2008000;
    instb[20] = 0x03e00008; // jr ra
    instb[21] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[9];
      gen_inputs_f32(i >> 0, &rs_ref[0], 9);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[9], rd_expected[9] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a20008;
        instb[3] = 0xc8a0000d;
        instb[4] = 0xc8a10011;
        instb[5] = 0xc8a20015;
        instb[6] = 0xc8a0001a;
        instb[7] = 0xc8a1001e;
        instb[8] = 0xc8a20022;
        instb[9] = 0xc8c40000;
        instb[10 + 1] = 0xe8880000;
        instb[11 + 1] = 0xe8890004;
        instb[12 + 1] = 0xe88a0008;
        instb[13 + 1] = 0xe888000d;
        instb[14 + 1] = 0xe8890011;
        instb[15 + 1] = 0xe88a0015;
        instb[16 + 1] = 0xe888001a;
        instb[17 + 1] = 0xe889001e;
        instb[18 + 1] = 0xe88a0022;
        instb[10] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 9); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix3[reg_rs] << 8);
          for (unsigned p = 0; p < 9; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_single1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[9 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_single1[reg_rt][p]];
            if (regcol(reg_mask_matrix3[reg_rs], reg_mask_single1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_matrix3[reg_rd] << 0);
              for (unsigned p = 0; p < 9; p++)
                instb[10 + p + 1] =
                    ((4) << 21) | ((p) << 2) |
                    reg_save_inst[subreg_map_matrix3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[10] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 9)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_matrix3[reg_rs], reg_mask_matrix3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_matrix3[reg_rs], reg_mask_matrix3[reg_rs],
                    rmap_matrix3[reg_rd], reg_mask_matrix3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_single1[reg_rt], reg_mask_matrix3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_single1[reg_rt], reg_mask_single1[reg_rt],
                    rmap_matrix3[reg_rd], reg_mask_matrix3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_matrix3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmscl.t
  entrycnt++;
  { // Tests for instruction vmscl.q (Matrix scale by single factor)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmscl.q\n");
    reginfo[entrycnt].inst_name = "vmscl.q";
    gen_full_rand(0xf2008080, &bg_noise[0], 128);
    uint32_t basew = 0xf2008080;
    instb[34] = 0x03e00008; // jr ra
    instb[35] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[16];
      gen_inputs_f32(i >> 0, &rs_ref[0], 16);
      float rt_ref[1];
      gen_inputs_f32(i >> 2, &rt_ref[0], 1);
      {
        float rd[16], rd_expected[16] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a20008;
        instb[3] = 0xc8a3000c;
        instb[4] = 0xc8a00011;
        instb[5] = 0xc8a10015;
        instb[6] = 0xc8a20019;
        instb[7] = 0xc8a3001d;
        instb[8] = 0xc8a00022;
        instb[9] = 0xc8a10026;
        instb[10] = 0xc8a2002a;
        instb[11] = 0xc8a3002e;
        instb[12] = 0xc8a00033;
        instb[13] = 0xc8a10037;
        instb[14] = 0xc8a2003b;
        instb[15] = 0xc8a3003f;
        instb[16] = 0xc8c40000;
        instb[17 + 1] = 0xe8880000;
        instb[18 + 1] = 0xe8890004;
        instb[19 + 1] = 0xe88a0008;
        instb[20 + 1] = 0xe88b000c;
        instb[21 + 1] = 0xe8880011;
        instb[22 + 1] = 0xe8890015;
        instb[23 + 1] = 0xe88a0019;
        instb[24 + 1] = 0xe88b001d;
        instb[25 + 1] = 0xe8880022;
        instb[26 + 1] = 0xe8890026;
        instb[27 + 1] = 0xe88a002a;
        instb[28 + 1] = 0xe88b002e;
        instb[29 + 1] = 0xe8880033;
        instb[30 + 1] = 0xe8890037;
        instb[31 + 1] = 0xe88a003b;
        instb[32 + 1] = 0xe88b003f;
        instb[17] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);   // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 16); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 16; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix4[reg_rs] << 8);
          for (unsigned p = 0; p < 16; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_single1[reg_rt] << 16);
            for (unsigned p = 0; p < 1; p++)
              instb[16 + p] = ((6) << 21) | ((p) << 2) |
                              reg_load_inst[subreg_map_single1[reg_rt][p]];
            if (regcol(reg_mask_matrix4[reg_rs], reg_mask_single1[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 16; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_matrix4[reg_rd] << 0);
              for (unsigned p = 0; p < 16; p++)
                instb[17 + p + 1] =
                    ((4) << 21) | ((p) << 2) |
                    reg_save_inst[subreg_map_matrix4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[17] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 16)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_matrix4[reg_rs], reg_mask_matrix4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_matrix4[reg_rs], reg_mask_matrix4[reg_rs],
                    rmap_matrix4[reg_rd], reg_mask_matrix4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_single1[reg_rt], reg_mask_matrix4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_single1[reg_rt], reg_mask_single1[reg_rt],
                    rmap_matrix4[reg_rd], reg_mask_matrix4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_matrix4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmscl.q
  entrycnt++;
  { // Tests for instruction vmmov.p (Copy matrix)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmmov.p\n");
    reginfo[entrycnt].inst_name = "vmmov.p";
    gen_full_rand(0xf3800080, &bg_noise[0], 128);
    uint32_t basew = 0xf3800080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a00009;
        instb[3] = 0xc8a1000d;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8850004;
        instb[6 + 1] = 0xe8840009;
        instb[7 + 1] = 0xe885000d;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix2[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_matrix2[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_matrix2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_matrix2[reg_rs], reg_mask_matrix2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_matrix2[reg_rs], reg_mask_matrix2[reg_rs],
                               rmap_matrix2[reg_rd], reg_mask_matrix2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_matrix2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmmov.p
  entrycnt++;
  { // Tests for instruction vmmov.t (Copy matrix)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmmov.t\n");
    reginfo[entrycnt].inst_name = "vmmov.t";
    gen_full_rand(0xf3808000, &bg_noise[0], 128);
    uint32_t basew = 0xf3808000;
    instb[19] = 0x03e00008; // jr ra
    instb[20] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[9];
      gen_inputs_f32(i >> 0, &rs_ref[0], 9);
      {
        float rd[9], rd_expected[9] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a20008;
        instb[3] = 0xc8a0000d;
        instb[4] = 0xc8a10011;
        instb[5] = 0xc8a20015;
        instb[6] = 0xc8a0001a;
        instb[7] = 0xc8a1001e;
        instb[8] = 0xc8a20022;
        instb[9 + 1] = 0xe8840000;
        instb[10 + 1] = 0xe8850004;
        instb[11 + 1] = 0xe8860008;
        instb[12 + 1] = 0xe884000d;
        instb[13 + 1] = 0xe8850011;
        instb[14 + 1] = 0xe8860015;
        instb[15 + 1] = 0xe884001a;
        instb[16 + 1] = 0xe885001e;
        instb[17 + 1] = 0xe8860022;
        instb[9] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 9); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix3[reg_rs] << 8);
          for (unsigned p = 0; p < 9; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix3[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_matrix3[reg_rd] << 0);
            for (unsigned p = 0; p < 9; p++)
              instb[9 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_matrix3[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[9] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 9)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_matrix3[reg_rs], reg_mask_matrix3[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_matrix3[reg_rs], reg_mask_matrix3[reg_rs],
                               rmap_matrix3[reg_rd], reg_mask_matrix3[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix3[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_matrix3[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmmov.t
  entrycnt++;
  { // Tests for instruction vmmov.q (Copy matrix)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmmov.q\n");
    reginfo[entrycnt].inst_name = "vmmov.q";
    gen_full_rand(0xf3808080, &bg_noise[0], 128);
    uint32_t basew = 0xf3808080;
    instb[33] = 0x03e00008; // jr ra
    instb[34] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      float rs_ref[16];
      gen_inputs_f32(i >> 0, &rs_ref[0], 16);
      {
        float rd[16], rd_expected[16] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a20008;
        instb[3] = 0xc8a3000c;
        instb[4] = 0xc8a00011;
        instb[5] = 0xc8a10015;
        instb[6] = 0xc8a20019;
        instb[7] = 0xc8a3001d;
        instb[8] = 0xc8a00022;
        instb[9] = 0xc8a10026;
        instb[10] = 0xc8a2002a;
        instb[11] = 0xc8a3002e;
        instb[12] = 0xc8a00033;
        instb[13] = 0xc8a10037;
        instb[14] = 0xc8a2003b;
        instb[15] = 0xc8a3003f;
        instb[16 + 1] = 0xe8840000;
        instb[17 + 1] = 0xe8850004;
        instb[18 + 1] = 0xe8860008;
        instb[19 + 1] = 0xe887000c;
        instb[20 + 1] = 0xe8840011;
        instb[21 + 1] = 0xe8850015;
        instb[22 + 1] = 0xe8860019;
        instb[23 + 1] = 0xe887001d;
        instb[24 + 1] = 0xe8840022;
        instb[25 + 1] = 0xe8850026;
        instb[26 + 1] = 0xe886002a;
        instb[27 + 1] = 0xe887002e;
        instb[28 + 1] = 0xe8840033;
        instb[29 + 1] = 0xe8850037;
        instb[30 + 1] = 0xe886003b;
        instb[31 + 1] = 0xe887003f;
        instb[16] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);           // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 16); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 16; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix4[reg_rs] << 8);
          for (unsigned p = 0; p < 16; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 16; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_matrix4[reg_rd] << 0);
            for (unsigned p = 0; p < 16; p++)
              instb[16 + p + 1] = ((4) << 21) | ((p) << 2) |
                                  reg_save_inst[subreg_map_matrix4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[16] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 16)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_matrix4[reg_rs], reg_mask_matrix4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_matrix4[reg_rs], reg_mask_matrix4[reg_rs],
                               rmap_matrix4[reg_rd], reg_mask_matrix4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_matrix4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vmmov.q
  entrycnt++;
  { // Tests for instruction vmidt.p (Set matrix to identity)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmidt.p\n");
    reginfo[entrycnt].inst_name = "vmidt.p";
    gen_full_rand(0xf3830080, &bg_noise[0], 128);
    uint32_t basew = 0xf3830080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8810004;
        instb[2 + 1] = 0xe8800009;
        instb[3 + 1] = 0xe881000d;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_matrix2[reg_rd] << 0);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_matrix2[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 4)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix2[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vmidt.p
  entrycnt++;
  { // Tests for instruction vmidt.t (Set matrix to identity)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmidt.t\n");
    reginfo[entrycnt].inst_name = "vmidt.t";
    gen_full_rand(0xf3838000, &bg_noise[0], 128);
    uint32_t basew = 0xf3838000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[9], rd_expected[9] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8810004;
        instb[2 + 1] = 0xe8820008;
        instb[3 + 1] = 0xe880000d;
        instb[4 + 1] = 0xe8810011;
        instb[5 + 1] = 0xe8820015;
        instb[6 + 1] = 0xe880001a;
        instb[7 + 1] = 0xe881001e;
        instb[8 + 1] = 0xe8820022;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 9); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_matrix3[reg_rd] << 0);
          for (unsigned p = 0; p < 9; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_matrix3[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 9)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix3[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vmidt.t
  entrycnt++;
  { // Tests for instruction vmidt.q (Set matrix to identity)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmidt.q\n");
    reginfo[entrycnt].inst_name = "vmidt.q";
    gen_full_rand(0xf3838080, &bg_noise[0], 128);
    uint32_t basew = 0xf3838080;
    instb[17] = 0x03e00008; // jr ra
    instb[18] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[16], rd_expected[16] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8810004;
        instb[2 + 1] = 0xe8820008;
        instb[3 + 1] = 0xe883000c;
        instb[4 + 1] = 0xe8800011;
        instb[5 + 1] = 0xe8810015;
        instb[6 + 1] = 0xe8820019;
        instb[7 + 1] = 0xe883001d;
        instb[8 + 1] = 0xe8800022;
        instb[9 + 1] = 0xe8810026;
        instb[10 + 1] = 0xe882002a;
        instb[11 + 1] = 0xe883002e;
        instb[12 + 1] = 0xe8800033;
        instb[13 + 1] = 0xe8810037;
        instb[14 + 1] = 0xe882003b;
        instb[15 + 1] = 0xe883003f;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                   // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 16); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 16; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_matrix4[reg_rd] << 0);
          for (unsigned p = 0; p < 16; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_matrix4[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 16)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix4[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vmidt.q
  entrycnt++;
  { // Tests for instruction vmzero.p (Clear matrix to zero)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmzero.p\n");
    reginfo[entrycnt].inst_name = "vmzero.p";
    gen_full_rand(0xf3860080, &bg_noise[0], 128);
    uint32_t basew = 0xf3860080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8810004;
        instb[2 + 1] = 0xe8800009;
        instb[3 + 1] = 0xe881000d;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_matrix2[reg_rd] << 0);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_matrix2[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 4)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix2[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vmzero.p
  entrycnt++;
  { // Tests for instruction vmzero.t (Clear matrix to zero)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmzero.t\n");
    reginfo[entrycnt].inst_name = "vmzero.t";
    gen_full_rand(0xf3868000, &bg_noise[0], 128);
    uint32_t basew = 0xf3868000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[9], rd_expected[9] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8810004;
        instb[2 + 1] = 0xe8820008;
        instb[3 + 1] = 0xe880000d;
        instb[4 + 1] = 0xe8810011;
        instb[5 + 1] = 0xe8820015;
        instb[6 + 1] = 0xe880001a;
        instb[7 + 1] = 0xe881001e;
        instb[8 + 1] = 0xe8820022;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 9); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_matrix3[reg_rd] << 0);
          for (unsigned p = 0; p < 9; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_matrix3[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 9)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix3[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vmzero.t
  entrycnt++;
  { // Tests for instruction vmzero.q (Clear matrix to zero)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmzero.q\n");
    reginfo[entrycnt].inst_name = "vmzero.q";
    gen_full_rand(0xf3868080, &bg_noise[0], 128);
    uint32_t basew = 0xf3868080;
    instb[17] = 0x03e00008; // jr ra
    instb[18] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[16], rd_expected[16] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8810004;
        instb[2 + 1] = 0xe8820008;
        instb[3 + 1] = 0xe883000c;
        instb[4 + 1] = 0xe8800011;
        instb[5 + 1] = 0xe8810015;
        instb[6 + 1] = 0xe8820019;
        instb[7 + 1] = 0xe883001d;
        instb[8 + 1] = 0xe8800022;
        instb[9 + 1] = 0xe8810026;
        instb[10 + 1] = 0xe882002a;
        instb[11 + 1] = 0xe883002e;
        instb[12 + 1] = 0xe8800033;
        instb[13 + 1] = 0xe8810037;
        instb[14 + 1] = 0xe882003b;
        instb[15 + 1] = 0xe883003f;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                   // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 16); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 16; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_matrix4[reg_rd] << 0);
          for (unsigned p = 0; p < 16; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_matrix4[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 16)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix4[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vmzero.q
  entrycnt++;
  { // Tests for instruction vmone.p (Clear matrix to one)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmone.p\n");
    reginfo[entrycnt].inst_name = "vmone.p";
    gen_full_rand(0xf3870080, &bg_noise[0], 128);
    uint32_t basew = 0xf3870080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8810004;
        instb[2 + 1] = 0xe8800009;
        instb[3 + 1] = 0xe881000d;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_matrix2[reg_rd] << 0);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_matrix2[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 4)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix2[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vmone.p
  entrycnt++;
  { // Tests for instruction vmone.t (Clear matrix to one)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmone.t\n");
    reginfo[entrycnt].inst_name = "vmone.t";
    gen_full_rand(0xf3878000, &bg_noise[0], 128);
    uint32_t basew = 0xf3878000;
    instb[10] = 0x03e00008; // jr ra
    instb[11] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[9], rd_expected[9] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8810004;
        instb[2 + 1] = 0xe8820008;
        instb[3 + 1] = 0xe880000d;
        instb[4 + 1] = 0xe8810011;
        instb[5 + 1] = 0xe8820015;
        instb[6 + 1] = 0xe880001a;
        instb[7 + 1] = 0xe881001e;
        instb[8 + 1] = 0xe8820022;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 9); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_matrix3[reg_rd] << 0);
          for (unsigned p = 0; p < 9; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_matrix3[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 9)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix3[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vmone.t
  entrycnt++;
  { // Tests for instruction vmone.q (Clear matrix to one)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vmone.q\n");
    reginfo[entrycnt].inst_name = "vmone.q";
    gen_full_rand(0xf3878080, &bg_noise[0], 128);
    uint32_t basew = 0xf3878080;
    instb[17] = 0x03e00008; // jr ra
    instb[18] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      {
        float rd[16], rd_expected[16] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8810004;
        instb[2 + 1] = 0xe8820008;
        instb[3 + 1] = 0xe883000c;
        instb[4 + 1] = 0xe8800011;
        instb[5 + 1] = 0xe8810015;
        instb[6 + 1] = 0xe8820019;
        instb[7 + 1] = 0xe883001d;
        instb[8 + 1] = 0xe8800022;
        instb[9 + 1] = 0xe8810026;
        instb[10 + 1] = 0xe882002a;
        instb[11 + 1] = 0xe883002e;
        instb[12 + 1] = 0xe8800033;
        instb[13 + 1] = 0xe8810037;
        instb[14 + 1] = 0xe882003b;
        instb[15 + 1] = 0xe883003f;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                   // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 16); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 16; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_matrix4[reg_rd] << 0);
          for (unsigned p = 0; p < 16; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_matrix4[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 16)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix4[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vmone.q
  entrycnt++;
  { // Tests for instruction vtfm2.p (Vector by matrix transform)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vtfm2.p\n");
    reginfo[entrycnt].inst_name = "vtfm2.p";
    gen_full_rand(0xf0800080, &bg_noise[0], 128);
    uint32_t basew = 0xf0800080;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a00009;
        instb[3] = 0xc8a1000d;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix2[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_matrix2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
              for (unsigned p = 0; p < 2; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 2)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_matrix2[reg_rs], reg_mask_vector2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_matrix2[reg_rs], reg_mask_matrix2[reg_rs],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_vector2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vtfm2.p
  entrycnt++;
  { // Tests for instruction vtfm3.t (Vector by matrix transform)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vtfm3.t\n");
    reginfo[entrycnt].inst_name = "vtfm3.t";
    gen_full_rand(0xf1008000, &bg_noise[0], 128);
    uint32_t basew = 0xf1008000;
    instb[16] = 0x03e00008; // jr ra
    instb[17] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[9];
      gen_inputs_f32(i >> 0, &rs_ref[0], 9);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a20008;
        instb[3] = 0xc8a0000d;
        instb[4] = 0xc8a10011;
        instb[5] = 0xc8a20015;
        instb[6] = 0xc8a0001a;
        instb[7] = 0xc8a1001e;
        instb[8] = 0xc8a20022;
        instb[9] = 0xc8c40000;
        instb[10] = 0xc8c40005;
        instb[11] = 0xc8c4000a;
        instb[12 + 1] = 0xe8880000;
        instb[13 + 1] = 0xe8880005;
        instb[14 + 1] = 0xe888000a;
        instb[12] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix3[reg_rs] << 8);
          for (unsigned p = 0; p < 9; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[9 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_matrix3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[12 + p + 1] =
                    ((4) << 21) | ((p) << 2) |
                    reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[12] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_matrix3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_matrix3[reg_rs], reg_mask_matrix3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vtfm3.t
  entrycnt++;
  { // Tests for instruction vtfm4.q (Vector by matrix transform)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vtfm4.q\n");
    reginfo[entrycnt].inst_name = "vtfm4.q";
    gen_full_rand(0xf1808080, &bg_noise[0], 128);
    uint32_t basew = 0xf1808080;
    instb[25] = 0x03e00008; // jr ra
    instb[26] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[16];
      gen_inputs_f32(i >> 0, &rs_ref[0], 16);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a20008;
        instb[3] = 0xc8a3000c;
        instb[4] = 0xc8a00011;
        instb[5] = 0xc8a10015;
        instb[6] = 0xc8a20019;
        instb[7] = 0xc8a3001d;
        instb[8] = 0xc8a00022;
        instb[9] = 0xc8a10026;
        instb[10] = 0xc8a2002a;
        instb[11] = 0xc8a3002e;
        instb[12] = 0xc8a00033;
        instb[13] = 0xc8a10037;
        instb[14] = 0xc8a2003b;
        instb[15] = 0xc8a3003f;
        instb[16] = 0xc8c40000;
        instb[17] = 0xc8c40005;
        instb[18] = 0xc8c4000a;
        instb[19] = 0xc8c4000f;
        instb[20 + 1] = 0xe8880000;
        instb[21 + 1] = 0xe8880005;
        instb[22 + 1] = 0xe888000a;
        instb[23 + 1] = 0xe888000f;
        instb[20] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 16; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix4[reg_rs] << 8);
          for (unsigned p = 0; p < 16; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[16 + p] = ((6) << 21) | ((p) << 2) |
                              reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_matrix4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[20 + p + 1] =
                    ((4) << 21) | ((p) << 2) |
                    reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[20] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_matrix4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_matrix4[reg_rs], reg_mask_matrix4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vtfm4.q
  entrycnt++;
  { // Tests for instruction vhtfm2.p (Vector by matrix homogeneous transform)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vhtfm2.p\n");
    reginfo[entrycnt].inst_name = "vhtfm2.p";
    gen_full_rand(0xf0800000, &bg_noise[0], 128);
    uint32_t basew = 0xf0800000;
    instb[9] = 0x03e00008;  // jr ra
    instb[10] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[4];
      gen_inputs_f32(i >> 0, &rs_ref[0], 4);
      float rt_ref[2];
      gen_inputs_f32(i >> 2, &rt_ref[0], 2);
      {
        float rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a00009;
        instb[3] = 0xc8a1000d;
        instb[4] = 0xc8c40000;
        instb[5] = 0xc8c40005;
        instb[6 + 1] = 0xe8880000;
        instb[7 + 1] = 0xe8880005;
        instb[6] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix2[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix2[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector2[reg_rt] << 16);
            for (unsigned p = 0; p < 2; p++)
              instb[4 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector2[reg_rt][p]];
            if (regcol(reg_mask_matrix2[reg_rs], reg_mask_vector2[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
              for (unsigned p = 0; p < 2; p++)
                instb[6 + p + 1] = ((4) << 21) | ((p) << 2) |
                                   reg_save_inst[subreg_map_vector2[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[6] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 2)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_matrix2[reg_rs], reg_mask_vector2[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_matrix2[reg_rs], reg_mask_matrix2[reg_rs],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector2[reg_rt], reg_mask_vector2[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector2[reg_rt], reg_mask_vector2[reg_rt],
                    rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix2[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector2[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vhtfm2.p
  entrycnt++;
  { // Tests for instruction vhtfm3.t (Vector by matrix homogeneous transform)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vhtfm3.t\n");
    reginfo[entrycnt].inst_name = "vhtfm3.t";
    gen_full_rand(0xf1000080, &bg_noise[0], 128);
    uint32_t basew = 0xf1000080;
    instb[16] = 0x03e00008; // jr ra
    instb[17] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[9];
      gen_inputs_f32(i >> 0, &rs_ref[0], 9);
      float rt_ref[3];
      gen_inputs_f32(i >> 2, &rt_ref[0], 3);
      {
        float rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a20008;
        instb[3] = 0xc8a0000d;
        instb[4] = 0xc8a10011;
        instb[5] = 0xc8a20015;
        instb[6] = 0xc8a0001a;
        instb[7] = 0xc8a1001e;
        instb[8] = 0xc8a20022;
        instb[9] = 0xc8c40000;
        instb[10] = 0xc8c40005;
        instb[11] = 0xc8c4000a;
        instb[12 + 1] = 0xe8880000;
        instb[13 + 1] = 0xe8880005;
        instb[14 + 1] = 0xe888000a;
        instb[12] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix3[reg_rs] << 8);
          for (unsigned p = 0; p < 9; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix3[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 128; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector3[reg_rt] << 16);
            for (unsigned p = 0; p < 3; p++)
              instb[9 + p] = ((6) << 21) | ((p) << 2) |
                             reg_load_inst[subreg_map_vector3[reg_rt][p]];
            if (regcol(reg_mask_matrix3[reg_rs], reg_mask_vector3[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
              for (unsigned p = 0; p < 3; p++)
                instb[12 + p + 1] =
                    ((4) << 21) | ((p) << 2) |
                    reg_save_inst[subreg_map_vector3[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[12] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 3)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_matrix3[reg_rs], reg_mask_vector3[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_matrix3[reg_rs], reg_mask_matrix3[reg_rs],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector3[reg_rt], reg_mask_vector3[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector3[reg_rt], reg_mask_vector3[reg_rt],
                    rmap_vector3[reg_rd], reg_mask_vector3[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix3[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector3[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector3[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vhtfm3.t
  entrycnt++;
  { // Tests for instruction vhtfm4.q (Vector by matrix homogeneous transform)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vhtfm4.q\n");
    reginfo[entrycnt].inst_name = "vhtfm4.q";
    gen_full_rand(0xf1808000, &bg_noise[0], 128);
    uint32_t basew = 0xf1808000;
    instb[25] = 0x03e00008; // jr ra
    instb[26] = 0x00000000; // nop
    for (unsigned i = 0; i < 16; i++) {
      float rs_ref[16];
      gen_inputs_f32(i >> 0, &rs_ref[0], 16);
      float rt_ref[4];
      gen_inputs_f32(i >> 2, &rt_ref[0], 4);
      {
        float rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a10004;
        instb[2] = 0xc8a20008;
        instb[3] = 0xc8a3000c;
        instb[4] = 0xc8a00011;
        instb[5] = 0xc8a10015;
        instb[6] = 0xc8a20019;
        instb[7] = 0xc8a3001d;
        instb[8] = 0xc8a00022;
        instb[9] = 0xc8a10026;
        instb[10] = 0xc8a2002a;
        instb[11] = 0xc8a3002e;
        instb[12] = 0xc8a00033;
        instb[13] = 0xc8a10037;
        instb[14] = 0xc8a2003b;
        instb[15] = 0xc8a3003f;
        instb[16] = 0xc8c40000;
        instb[17] = 0xc8c40005;
        instb[18] = 0xc8c4000a;
        instb[19] = 0xc8c4000f;
        instb[20 + 1] = 0xe8880000;
        instb[21 + 1] = 0xe8880005;
        instb[22 + 1] = 0xe888000a;
        instb[23 + 1] = 0xe888000f;
        instb[20] = (basew & 0xff808080) | 0x00040008; // Setup instruction word
        jit_finish();
        jit_jump2(rd, rs_ref, rt_ref);  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 16; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_matrix4[reg_rs] << 8);
          for (unsigned p = 0; p < 16; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_matrix4[reg_rs][p]];
          for (unsigned reg_rt = 0; reg_rt < 64; reg_rt++) {
            basew = (basew & (~(0x7f << 16))) | (rmap_vector4[reg_rt] << 16);
            for (unsigned p = 0; p < 4; p++)
              instb[16 + p] = ((6) << 21) | ((p) << 2) |
                              reg_load_inst[subreg_map_vector4[reg_rt][p]];
            if (regcol(reg_mask_matrix4[reg_rs], reg_mask_vector4[reg_rt]))
              continue; // Input overlap!
            for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
              basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
              for (unsigned p = 0; p < 4; p++)
                instb[20 + p + 1] =
                    ((4) << 21) | ((p) << 2) |
                    reg_save_inst[subreg_map_vector4[reg_rd][p]];
              load_all_vfpu_regs((float *)&bg_noise[0]);
              instb[20] = basew; // Setup instruction word
              jit_finish();
              jit_jump2(rd, rs_ref, rt_ref); // Calls the asm code and returns
              if (memcmp(rd, rd_expected, 4 * 4)) {
                reginfo[entrycnt].test_errs++;
                int col_rs =
                    regcol(reg_mask_matrix4[reg_rs], reg_mask_vector4[reg_rd]);
                int compat_rs = regcompatcol(
                    rmap_matrix4[reg_rs], reg_mask_matrix4[reg_rs],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                int col_rt =
                    regcol(reg_mask_vector4[reg_rt], reg_mask_vector4[reg_rd]);
                int compat_rt = regcompatcol(
                    rmap_vector4[reg_rt], reg_mask_vector4[reg_rt],
                    rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
                if (0 || col_rs || col_rt) {
                  if (1 && (compat_rs || !col_rs) && (compat_rt || !col_rt))
                    reginfo[entrycnt].compat_overlap_errors++;
                  else
                    reginfo[entrycnt].incompat_overlap_errors++;
                } else
                  reginfo[entrycnt].nonoverlap_errors++;
                if (dbgcnt < REG_PAIRS_DEBUGS) {
                  reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_matrix4[reg_rs];
                  reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rt];
                  reginfo[entrycnt].reg_pairs[dbgcnt][2] = rmap_vector4[reg_rd];
                  dbgcnt++;
                }
              }
              reginfo[entrycnt].test_cnt++;
            } // for reg_rd
          }   // for reg_rt
        }     // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vhtfm4.q
  entrycnt++;
  { // Tests for instruction vi2uc.q (Pack integer to unsigned char)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vi2uc.q\n");
    reginfo[entrycnt].inst_name = "vi2uc.q";
    gen_full_rand(0xd03c8080, &bg_noise[0], 128);
    uint32_t basew = 0xd03c8080;
    instb[6] = 0x03e00008; // jr ra
    instb[7] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[4];
      gen_inputs_u32(i >> 0, &rs_ref[0], 4);
      {
        unsigned int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_single1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_single1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vi2uc.q
  entrycnt++;
  { // Tests for instruction vi2c.q (Pack integer to char)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vi2c.q\n");
    reginfo[entrycnt].inst_name = "vi2c.q";
    gen_full_rand(0xd03d8080, &bg_noise[0], 128);
    uint32_t basew = 0xd03d8080;
    instb[6] = 0x03e00008; // jr ra
    instb[7] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[4];
      gen_inputs_u32(i >> 0, &rs_ref[0], 4);
      {
        unsigned int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_single1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_single1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_single1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_single1[reg_rd], reg_mask_single1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_single1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vi2c.q
  entrycnt++;
  { // Tests for instruction vi2us.p (Pack integer to unsigned short)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vi2us.p\n");
    reginfo[entrycnt].inst_name = "vi2us.p";
    gen_full_rand(0xd03e0080, &bg_noise[0], 128);
    uint32_t basew = 0xd03e0080;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[2];
      gen_inputs_u32(i >> 0, &rs_ref[0], 2);
      {
        unsigned int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vi2us.p
  entrycnt++;
  { // Tests for instruction vi2us.q (Pack integer to unsigned short)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vi2us.q\n");
    reginfo[entrycnt].inst_name = "vi2us.q";
    gen_full_rand(0xd03e8080, &bg_noise[0], 128);
    uint32_t basew = 0xd03e8080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[4];
      gen_inputs_u32(i >> 0, &rs_ref[0], 4);
      {
        unsigned int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vi2us.q
  entrycnt++;
  { // Tests for instruction vi2s.p (Pack integer to short)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vi2s.p\n");
    reginfo[entrycnt].inst_name = "vi2s.p";
    gen_full_rand(0xd03f0080, &bg_noise[0], 128);
    uint32_t basew = 0xd03f0080;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[2];
      gen_inputs_u32(i >> 0, &rs_ref[0], 2);
      {
        unsigned int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vi2s.p
  entrycnt++;
  { // Tests for instruction vi2s.q (Pack integer to short)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vi2s.q\n");
    reginfo[entrycnt].inst_name = "vi2s.q";
    gen_full_rand(0xd03f8080, &bg_noise[0], 128);
    uint32_t basew = 0xd03f8080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[4];
      gen_inputs_u32(i >> 0, &rs_ref[0], 4);
      {
        unsigned int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vi2s.q
  entrycnt++;
  { // Tests for instruction vf2h.p (Pack float to float16)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2h.p\n");
    reginfo[entrycnt].inst_name = "vf2h.p";
    gen_full_rand(0xd0320080, &bg_noise[0], 128);
    uint32_t basew = 0xd0320080;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[2];
      gen_inputs_u32(i >> 0, &rs_ref[0], 2);
      {
        unsigned int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
            for (unsigned p = 0; p < 1; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector1[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 1)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector1[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector1[reg_rd], reg_mask_vector1[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector1[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2h.p
  entrycnt++;
  { // Tests for instruction vf2h.q (Pack float to float16)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vf2h.q\n");
    reginfo[entrycnt].inst_name = "vf2h.q";
    gen_full_rand(0xd0328080, &bg_noise[0], 128);
    uint32_t basew = 0xd0328080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[4];
      gen_inputs_u32(i >> 0, &rs_ref[0], 4);
      {
        unsigned int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vf2h.q
  entrycnt++;
  { // Tests for instruction vs2i.s (Unpack short to integer)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vs2i.s\n");
    reginfo[entrycnt].inst_name = "vs2i.s";
    gen_full_rand(0xd03b0000, &bg_noise[0], 128);
    uint32_t basew = 0xd03b0000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[1];
      gen_inputs_u32(i >> 0, &rs_ref[0], 1);
      {
        unsigned int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[2 + 1] = 0xe8840005;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vs2i.s
  entrycnt++;
  { // Tests for instruction vs2i.p (Unpack short to integer)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vs2i.p\n");
    reginfo[entrycnt].inst_name = "vs2i.p";
    gen_full_rand(0xd03b0080, &bg_noise[0], 128);
    uint32_t basew = 0xd03b0080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[2];
      gen_inputs_u32(i >> 0, &rs_ref[0], 2);
      {
        unsigned int rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[4 + 1] = 0xe884000a;
        instb[5 + 1] = 0xe884000f;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vs2i.p
  entrycnt++;
  { // Tests for instruction vus2i.s (Unpack short to unsigned integer)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vus2i.s\n");
    reginfo[entrycnt].inst_name = "vus2i.s";
    gen_full_rand(0xd03a0000, &bg_noise[0], 128);
    uint32_t basew = 0xd03a0000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[1];
      gen_inputs_u32(i >> 0, &rs_ref[0], 1);
      {
        unsigned int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[2 + 1] = 0xe8840005;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vus2i.s
  entrycnt++;
  { // Tests for instruction vus2i.p (Unpack short to unsigned integer)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vus2i.p\n");
    reginfo[entrycnt].inst_name = "vus2i.p";
    gen_full_rand(0xd03a0080, &bg_noise[0], 128);
    uint32_t basew = 0xd03a0080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[2];
      gen_inputs_u32(i >> 0, &rs_ref[0], 2);
      {
        unsigned int rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[4 + 1] = 0xe884000a;
        instb[5 + 1] = 0xe884000f;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vus2i.p
  entrycnt++;
  { // Tests for instruction vc2i.s (Unpack char to integer)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vc2i.s\n");
    reginfo[entrycnt].inst_name = "vc2i.s";
    gen_full_rand(0xd0390000, &bg_noise[0], 128);
    uint32_t basew = 0xd0390000;
    instb[6] = 0x03e00008; // jr ra
    instb[7] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[1];
      gen_inputs_u32(i >> 0, &rs_ref[0], 1);
      {
        unsigned int rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[2 + 1] = 0xe8840005;
        instb[3 + 1] = 0xe884000a;
        instb[4 + 1] = 0xe884000f;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vc2i.s
  entrycnt++;
  { // Tests for instruction vuc2ifs.s (Unpack char to unsigned integer)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vuc2ifs.s\n");
    reginfo[entrycnt].inst_name = "vuc2ifs.s";
    gen_full_rand(0xd0380000, &bg_noise[0], 128);
    uint32_t basew = 0xd0380000;
    instb[6] = 0x03e00008; // jr ra
    instb[7] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[1];
      gen_inputs_u32(i >> 0, &rs_ref[0], 1);
      {
        unsigned int rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[2 + 1] = 0xe8840005;
        instb[3 + 1] = 0xe884000a;
        instb[4 + 1] = 0xe884000f;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vuc2ifs.s
  entrycnt++;
  { // Tests for instruction vh2f.s (Unpack float16 to float)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vh2f.s\n");
    reginfo[entrycnt].inst_name = "vh2f.s";
    gen_full_rand(0xd0330000, &bg_noise[0], 128);
    uint32_t basew = 0xd0330000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[1];
      gen_inputs_u32(i >> 0, &rs_ref[0], 1);
      {
        unsigned int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1 + 1] = 0xe8840000;
        instb[2 + 1] = 0xe8840005;
        instb[1] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector1[reg_rs] << 8);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector1[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[1 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[1] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector1[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector1[reg_rs], reg_mask_vector1[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vh2f.s
  entrycnt++;
  { // Tests for instruction vh2f.p (Unpack float16 to float)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vh2f.p\n");
    reginfo[entrycnt].inst_name = "vh2f.p";
    gen_full_rand(0xd0330080, &bg_noise[0], 128);
    uint32_t basew = 0xd0330080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[2];
      gen_inputs_u32(i >> 0, &rs_ref[0], 2);
      {
        unsigned int rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2 + 1] = 0xe8840000;
        instb[3 + 1] = 0xe8840005;
        instb[4 + 1] = 0xe884000a;
        instb[5 + 1] = 0xe884000f;
        instb[2] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 128; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector2[reg_rs] << 8);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector2[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
            for (unsigned p = 0; p < 4; p++)
              instb[2 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector4[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[2] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 4)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector2[reg_rs], reg_mask_vector4[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector2[reg_rs], reg_mask_vector2[reg_rs],
                               rmap_vector4[reg_rd], reg_mask_vector4[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector4[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vh2f.p
  entrycnt++;
  { // Tests for instruction vt4444.q (ABGR4444 color conversion)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vt4444.q\n");
    reginfo[entrycnt].inst_name = "vt4444.q";
    gen_full_rand(0xd0598080, &bg_noise[0], 128);
    uint32_t basew = 0xd0598080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[4];
      gen_inputs_u32(i >> 0, &rs_ref[0], 4);
      {
        unsigned int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vt4444.q
  entrycnt++;
  { // Tests for instruction vt5551.q (ABGR1555 color conversion)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vt5551.q\n");
    reginfo[entrycnt].inst_name = "vt5551.q";
    gen_full_rand(0xd05a8080, &bg_noise[0], 128);
    uint32_t basew = 0xd05a8080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[4];
      gen_inputs_u32(i >> 0, &rs_ref[0], 4);
      {
        unsigned int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vt5551.q
  entrycnt++;
  { // Tests for instruction vt5650.q (BGR565 color conversion)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vt5650.q\n");
    reginfo[entrycnt].inst_name = "vt5650.q";
    gen_full_rand(0xd05b8080, &bg_noise[0], 128);
    uint32_t basew = 0xd05b8080;
    instb[7] = 0x03e00008; // jr ra
    instb[8] = 0x00000000; // nop
    for (unsigned i = 0; i < 4; i++) {
      unsigned int rs_ref[4];
      gen_inputs_u32(i >> 0, &rs_ref[0], 4);
      {
        unsigned int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0] = 0xc8a00000;
        instb[1] = 0xc8a00005;
        instb[2] = 0xc8a0000a;
        instb[3] = 0xc8a0000f;
        instb[4 + 1] = 0xe8840000;
        instb[5 + 1] = 0xe8840005;
        instb[4] = (basew & 0xffff8080) | 0x00000004; // Setup instruction word
        jit_finish();
        jit_jump1(rd, rs_ref);          // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rs = 0; reg_rs < 64; reg_rs++) {
          basew = (basew & (~(0x7f << 8))) | (rmap_vector4[reg_rs] << 8);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p] = ((5) << 21) | ((p) << 2) |
                           reg_load_inst[subreg_map_vector4[reg_rs][p]];
          for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
            basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
            for (unsigned p = 0; p < 2; p++)
              instb[4 + p + 1] = ((4) << 21) | ((p) << 2) |
                                 reg_save_inst[subreg_map_vector2[reg_rd][p]];
            load_all_vfpu_regs((float *)&bg_noise[0]);
            instb[4] = basew; // Setup instruction word
            jit_finish();
            jit_jump1(rd, rs_ref); // Calls the asm code and returns
            if (memcmp(rd, rd_expected, 4 * 2)) {
              reginfo[entrycnt].test_errs++;
              int col_rs =
                  regcol(reg_mask_vector4[reg_rs], reg_mask_vector2[reg_rd]);
              int compat_rs =
                  regcompatcol(rmap_vector4[reg_rs], reg_mask_vector4[reg_rs],
                               rmap_vector2[reg_rd], reg_mask_vector2[reg_rd]);
              if (0 || col_rs) {
                if (1 && (compat_rs || !col_rs))
                  reginfo[entrycnt].compat_overlap_errors++;
                else
                  reginfo[entrycnt].incompat_overlap_errors++;
              } else
                reginfo[entrycnt].nonoverlap_errors++;
              if (dbgcnt < REG_PAIRS_DEBUGS) {
                reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rs];
                reginfo[entrycnt].reg_pairs[dbgcnt][1] = rmap_vector2[reg_rd];
                dbgcnt++;
              }
            }
            reginfo[entrycnt].test_cnt++;
          } // for reg_rd
        }   // for reg_rs
      }
    } // test case iteration 'i' end
  }   // test case end for vt5650.q
  entrycnt++;
  { // Tests for instruction viim.s (Load constant integer value)
    int dbgcnt = 0;
    logprintf("Testing reg compat for viim.s\n");
    reginfo[entrycnt].inst_name = "viim.s";
    gen_full_rand(0xdf000000, &bg_noise[0], 128);
    uint32_t basew = 0xdf000000;
    instb[2] = 0x03e00008; // jr ra
    instb[3] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      const unsigned int immseq[][1] = {
          {0},     {65535}, {59180}, {35709}, {27306}, {56406}, {56517},
          {2125},  {44212}, {38341}, {8243},  {63840}, {8226},  {42792},
          {7774},  {5472},  {6065},  {26005}, {64607}, {59853}, {28578},
          {59175}, {11098}, {35233}, {5816},  {54101}, {42389}, {7042},
          {53909}, {34146}, {9311},  {48112}, {42068}, {18196}, {43841},
          {17854}, {31580}, {51562}, {57266}, {4755},  {45040}, {53288},
          {2194},  {45357}, {35214}, {39390}, {16920}, {53729}, {11007},
          {7622},  {15139}, {44999}, {39863}, {58313}, {48891}, {13134},
          {60481}, {6796},  {57249}, {29777}, {24678}, {9229},  {38182},
          {59130}, {58886}, {55815},
      };
      for (unsigned imcnt = 0; imcnt < 66; imcnt++) {
        basew = (basew & (~(0xffff << 0))) | (immseq[imcnt][0] << 0);
        float rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[0] = (basew & 0xff80ffff) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
          basew = (basew & (~(0x7f << 16))) | (rmap_single1[reg_rd] << 16);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_single1[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 1)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_single1[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for viim.s
  entrycnt++;
  { // Tests for instruction vfim.s (Load constant float value)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vfim.s\n");
    reginfo[entrycnt].inst_name = "vfim.s";
    gen_full_rand(0xdf800000, &bg_noise[0], 128);
    uint32_t basew = 0xdf800000;
    instb[2] = 0x03e00008; // jr ra
    instb[3] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      const unsigned int immseq[][1] = {
          {0},     {65535}, {49931}, {52752}, {39655}, {21941}, {52057},
          {58051}, {31878}, {30602}, {32096}, {45311}, {38699}, {59555},
          {16065}, {975},   {32178}, {19054}, {1058},  {5605},  {37420},
          {7412},  {112},   {36707}, {30011}, {15331}, {8928},  {47939},
          {12831}, {61246}, {22492}, {44196}, {50654}, {20984}, {46579},
          {59487}, {23526}, {16960}, {55947}, {33060}, {866},   {48365},
          {41803}, {56368}, {51445}, {51482}, {21475}, {35739}, {48831},
          {3027},  {27335}, {48361}, {12460}, {19164}, {50759}, {52111},
          {5669},  {17470}, {37589}, {47562}, {2748},  {14080}, {15498},
          {22683}, {51702}, {44093},
      };
      for (unsigned imcnt = 0; imcnt < 66; imcnt++) {
        basew = (basew & (~(0xffff << 0))) | (immseq[imcnt][0] << 0);
        unsigned int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[0] = (basew & 0xff80ffff) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
          basew = (basew & (~(0x7f << 16))) | (rmap_single1[reg_rd] << 16);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_single1[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 1)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_single1[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vfim.s
  entrycnt++;
  { // Tests for instruction vcst.s (Load special constant)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vcst.s\n");
    reginfo[entrycnt].inst_name = "vcst.s";
    gen_full_rand(0xd0600000, &bg_noise[0], 128);
    uint32_t basew = 0xd0600000;
    instb[2] = 0x03e00008; // jr ra
    instb[3] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      const unsigned int immseq[][1] = {
          {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19},
      };
      for (unsigned imcnt = 0; imcnt < 19; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        unsigned int rd[1], rd_expected[1] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 1); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_vector1[reg_rd] << 0);
          for (unsigned p = 0; p < 1; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_vector1[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 1)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector1[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vcst.s
  entrycnt++;
  { // Tests for instruction vcst.p (Load special constant)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vcst.p\n");
    reginfo[entrycnt].inst_name = "vcst.p";
    gen_full_rand(0xd0600080, &bg_noise[0], 128);
    uint32_t basew = 0xd0600080;
    instb[3] = 0x03e00008; // jr ra
    instb[4] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      const unsigned int immseq[][1] = {
          {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19},
      };
      for (unsigned imcnt = 0; imcnt < 19; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        unsigned int rd[2], rd_expected[2] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8800005;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 2); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_vector2[reg_rd] << 0);
          for (unsigned p = 0; p < 2; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_vector2[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 2)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector2[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vcst.p
  entrycnt++;
  { // Tests for instruction vcst.t (Load special constant)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vcst.t\n");
    reginfo[entrycnt].inst_name = "vcst.t";
    gen_full_rand(0xd0608000, &bg_noise[0], 128);
    uint32_t basew = 0xd0608000;
    instb[4] = 0x03e00008; // jr ra
    instb[5] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      const unsigned int immseq[][1] = {
          {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19},
      };
      for (unsigned imcnt = 0; imcnt < 19; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        unsigned int rd[3], rd_expected[3] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8800005;
        instb[2 + 1] = 0xe880000a;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 3); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 128; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_vector3[reg_rd] << 0);
          for (unsigned p = 0; p < 3; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_vector3[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 3)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector3[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vcst.t
  entrycnt++;
  { // Tests for instruction vcst.q (Load special constant)
    int dbgcnt = 0;
    logprintf("Testing reg compat for vcst.q\n");
    reginfo[entrycnt].inst_name = "vcst.q";
    gen_full_rand(0xd0608080, &bg_noise[0], 128);
    uint32_t basew = 0xd0608080;
    instb[5] = 0x03e00008; // jr ra
    instb[6] = 0x00000000; // nop
    for (unsigned i = 0; i < 1; i++) {
      const unsigned int immseq[][1] = {
          {1},  {2},  {3},  {4},  {5},  {6},  {7},  {8},  {9},  {10},
          {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19},
      };
      for (unsigned imcnt = 0; imcnt < 19; imcnt++) {
        basew = (basew & (~(0x1f << 16))) | (immseq[imcnt][0] << 16);
        unsigned int rd[4], rd_expected[4] = {0};
        // Reference code/output
        load_all_vfpu_regs((float *)&bg_noise[0]);
        instb[0 + 1] = 0xe8800000;
        instb[1 + 1] = 0xe8800005;
        instb[2 + 1] = 0xe880000a;
        instb[3 + 1] = 0xe880000f;
        instb[0] = (basew & 0xffffff80) | 0x00000000; // Setup instruction word
        jit_finish();
        jit_jump0(rd);                  // Calls the asm code and returns
        memcpy(rd_expected, rd, 4 * 4); // Save for later
        for (unsigned reg_rd = 0; reg_rd < 64; reg_rd++) {
          basew = (basew & (~(0x7f << 0))) | (rmap_vector4[reg_rd] << 0);
          for (unsigned p = 0; p < 4; p++)
            instb[0 + p + 1] = ((4) << 21) | ((p) << 2) |
                               reg_save_inst[subreg_map_vector4[reg_rd][p]];
          load_all_vfpu_regs((float *)&bg_noise[0]);
          instb[0] = basew; // Setup instruction word
          jit_finish();
          jit_jump0(rd); // Calls the asm code and returns
          if (memcmp(rd, rd_expected, 4 * 4)) {
            reginfo[entrycnt].test_errs++;
            if (0) {
              if (1)
                reginfo[entrycnt].compat_overlap_errors++;
              else
                reginfo[entrycnt].incompat_overlap_errors++;
            } else
              reginfo[entrycnt].nonoverlap_errors++;
            if (dbgcnt < REG_PAIRS_DEBUGS) {
              reginfo[entrycnt].reg_pairs[dbgcnt][0] = rmap_vector4[reg_rd];
              dbgcnt++;
            }
          }
          reginfo[entrycnt].test_cnt++;
        } // for reg_rd
      }
    } // test case iteration 'i' end
  }   // test case end for vcst.q
  entrycnt++;
  return entrycnt;
}
