#include "func-def.h"
#include "prefix-func.h"
#include "test-utils.h"
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
static unsigned comparefn(unsigned cond, float rs, float rt) {
  switch (cond) {
  case 0:
    return 0;
  case 1:
    return rs == rt;
  case 2:
    return rs < rt;
  case 3:
    return rs <= rt;
  case 4:
    return 1;
  case 5:
    return rs != rt;
  case 6:
    return rs >= rt;
  case 7:
    return rs > rt;
  case 8:
    return rs == 0;
  case 9:
    return isnan(rs);
  case 10:
    return isinf(rs);
  case 11:
    return isinf(rs) || isnan(rs);
  case 12:
    return rs != 0;
  case 13:
    return !isnan(rs);
  case 14:
    return !isinf(rs);
  case 15:
    return !isnan(rs) && !isinf(rs);
  };
}
int run_vcmp_s(struct test_error_info *errlist,
               struct prefix_usage_info *pfxinfo) {
  int errcnt = 0;
  // Tests for instruction vcmp.s (Compare vector elements)
  for (unsigned i = 0; i < 16384; i++) {
    float rs_ref[1];
    float rt_ref[1];
    gen_inputs_f32(i >> 0, &rs_ref[0], 1);
    gen_inputs_f32(i >> 7, &rt_ref[0], 1);
    pfxinfo->inst_name = "vcmp.s";
    pfxinfo->rs_tested = 1;
    pfxinfo->rt_tested = 1;
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdc0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[1];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 1);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdd0000e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[1];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 1);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040000,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040001,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040002,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040003,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040004,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040005,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040006,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040007,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040008,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c040009,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04000a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000a,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04000b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000b,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04000c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000c,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04000d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000d,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04000e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000e,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[4] = vfpu_cc[0];
      vfpu_cc[5] = vfpu_cc[0];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04000f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.s",
            .instw = 0x6c04000f,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 1},
                {.inpname = "rt", .size = 1},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
  }

  return errcnt;
}
int run_vcmp_p(struct test_error_info *errlist,
               struct prefix_usage_info *pfxinfo) {
  int errcnt = 0;
  // Tests for instruction vcmp.p (Compare vector elements)
  for (unsigned i = 0; i < 16384; i++) {
    float rs_ref[2];
    float rt_ref[2];
    gen_inputs_f32(i >> 0, &rs_ref[0], 2);
    gen_inputs_f32(i >> 7, &rt_ref[0], 2);
    pfxinfo->inst_name = "vcmp.p";
    pfxinfo->rs_tested = 1;
    pfxinfo->rt_tested = 1;
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000e1, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000e1" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdc0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[2];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 2);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000e1, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000e1" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdd0000e1,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[2];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 2);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040080,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040081,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040082,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040083,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040084,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040085,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040086,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040087,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040088,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c040089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c040089,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04008a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008a,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04008b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008b,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04008c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008c,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04008d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008d,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04008e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008e,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04008f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.p",
            .instw = 0x6c04008f,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 2},
                {.inpname = "rt", .size = 2},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
  }

  return errcnt;
}
int run_vcmp_t(struct test_error_info *errlist,
               struct prefix_usage_info *pfxinfo) {
  int errcnt = 0;
  // Tests for instruction vcmp.t (Compare vector elements)
  for (unsigned i = 0; i < 16384; i++) {
    float rs_ref[3];
    float rt_ref[3];
    gen_inputs_f32(i >> 0, &rs_ref[0], 3);
    gen_inputs_f32(i >> 7, &rt_ref[0], 3);
    pfxinfo->inst_name = "vcmp.t";
    pfxinfo->rs_tested = 1;
    pfxinfo->rt_tested = 1;
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0000c9, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0000c9" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdc0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[3];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 3);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0000c9, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0000c9" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdd0000c9,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[3];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 3);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048000" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048000,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048001" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048001,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048002" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048002,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048003" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048003,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048004" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048004,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048005" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048005,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048006" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048006,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048007" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048007,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048008" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048008,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048009" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c048009,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04800a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800a,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04800b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800b,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04800c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800c,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04800d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800d,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04800e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800e,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04800f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.t",
            .instw = 0x6c04800f,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 3},
                {.inpname = "rt", .size = 3},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
  }

  return errcnt;
}
int run_vcmp_q(struct test_error_info *errlist,
               struct prefix_usage_info *pfxinfo) {
  int errcnt = 0;
  // Tests for instruction vcmp.q (Compare vector elements)
  for (unsigned i = 0; i < 16384; i++) {
    float rs_ref[4];
    float rt_ref[4];
    gen_inputs_f32(i >> 0, &rs_ref[0], 4);
    gen_inputs_f32(i >> 7, &rt_ref[0], 4);
    pfxinfo->inst_name = "vcmp.q";
    pfxinfo->rs_tested = 1;
    pfxinfo->rt_tested = 1;
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000039, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000039" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdc000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_swz);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0500e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0500e4" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdc0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0a00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0a00e4" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdc0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0f00e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0f00e4" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdc0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_neg);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc0005e4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc0005e4" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdc0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000ae4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000ae4" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdc000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc000fe4, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc000fe4" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdc000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_abs);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rs[4];
      pfx_src((uint32_t *)&rs[0], (uint32_t *)&rs_ref[0], 0xdc00f4a7, 4);
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdc00f4a7" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rs_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdc00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rs_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000039, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000039" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_swz_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdd000039,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_swz);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0500e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0500e4" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdd0500e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0a00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0a00e4" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdd0a00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0f00e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0f00e4" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_neg_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdd0f00e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_neg);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd0005e4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd0005e4" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdd0005e4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000ae4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000ae4" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdd000ae4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd000fe4, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd000fe4" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_abs_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdd000fe4,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_abs);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float rt[4];
      pfx_src((uint32_t *)&rt[0], (uint32_t *)&rt_ref[0], 0xdd00f4a7, 4);
      float *rs = &rs_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0xdd00f4a7" ::: "memory");
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &pfxinfo->rt_cst_err;
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0xdd00f4a7,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        pfxinfo->rt_errors |= (1 << enum_cst);
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 0;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048080" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048080,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 1;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048081" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048081,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 2;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048082" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048082,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 3;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048083" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048083,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 4;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048084" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048084,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 5;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048085" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048085,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 6;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048086" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048086,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 7;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048087" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048087,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 8;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048088" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048088,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 9;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c048089" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c048089,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 10;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04808a" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808a,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 11;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04808b" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808b,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 12;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04808c" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808c,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 13;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04808d" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808d,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 14;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04808e" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808e,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
    {
      float *rs = &rs_ref[0]; // No src prefix
      float *rt = &rt_ref[0]; // No src prefix
      unsigned int vfpu_cc[6] = {0}, vfpu_cc_out[6] = {0};
      asm volatile("mtvc $0, $131;vmzero.q M400");
      asm volatile("lv.s S000, 0*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S001, 1*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S002, 2*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S003, 3*4(%0)" ::"r"(&rs_ref[0]));
      asm volatile("lv.s S100, 0*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S101, 1*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S102, 2*4(%0)" ::"r"(&rt_ref[0]));
      asm volatile("lv.s S103, 3*4(%0)" ::"r"(&rt_ref[0]));
      unsigned cond = 15;
      vfpu_cc[0] = comparefn(cond, rs[0], rt[0]);
      vfpu_cc[1] = comparefn(cond, rs[1], rt[1]);
      vfpu_cc[2] = comparefn(cond, rs[2], rt[2]);
      vfpu_cc[3] = comparefn(cond, rs[3], rt[3]);
      vfpu_cc[4] = vfpu_cc[0] | vfpu_cc[1] | vfpu_cc[2] | vfpu_cc[3];
      vfpu_cc[5] = vfpu_cc[0] & vfpu_cc[1] & vfpu_cc[2] & vfpu_cc[3];
      unsigned int *vfpu_cc_final = &vfpu_cc[0]; // No dst prefix
      asm volatile(".word 0x6c04808f" ::: "memory");
      asm volatile("vnop; mfvc %0, $131" : "=r"(vfpu_cc_out[0]));
      int mm = (pack6(vfpu_cc_final) != vfpu_cc_out[0]);
      if (mm) {
        struct test_error_info *rep = &errlist[errcnt];
        static const struct test_decl_info iinfo = {
            .inst = "vcmp.q",
            .instw = 0x6c04808f,
            .pfxw = 0x00000000,
            .rdoutsz = 6,
            .inputs = {
                {.inpname = "rs", .size = 4},
                {.inpname = "rt", .size = 4},
            }};
        fill_errinfo(rep, &iinfo, vfpu_cc_final, vfpu_cc_out);
        fill_reg(rep->inputs[0], rs_ref);
        fill_reg(rep->inputs[1], rt_ref);
        errcnt++;
        break;
      }
    }
  }

  return errcnt;
}
